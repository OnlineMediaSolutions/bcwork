// Code generated by http://github.com/gojuno/minimock (v3.3.6). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m6yf/bcwork/storage/db.PublisherSyncStorage -o publisher_sync_storage_mock.go -n PublisherSyncStorageMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/m6yf/bcwork/models"
	"github.com/volatiletech/sqlboiler/v4/boil"
)

// PublisherSyncStorageMock implements db.PublisherSyncStorage
type PublisherSyncStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcHadLoadingErrorLastTime          func(ctx context.Context, key string) (b1 bool)
	inspectFuncHadLoadingErrorLastTime   func(ctx context.Context, key string)
	afterHadLoadingErrorLastTimeCounter  uint64
	beforeHadLoadingErrorLastTimeCounter uint64
	HadLoadingErrorLastTimeMock          mPublisherSyncStorageMockHadLoadingErrorLastTime

	funcInsertPublisherDomain          func(ctx context.Context, domain *models.PublisherDomain) (err error)
	inspectFuncInsertPublisherDomain   func(ctx context.Context, domain *models.PublisherDomain)
	afterInsertPublisherDomainCounter  uint64
	beforeInsertPublisherDomainCounter uint64
	InsertPublisherDomainMock          mPublisherSyncStorageMockInsertPublisherDomain

	funcSaveResultOfLastSync          func(ctx context.Context, key string, hasErrors bool) (err error)
	inspectFuncSaveResultOfLastSync   func(ctx context.Context, key string, hasErrors bool)
	afterSaveResultOfLastSyncCounter  uint64
	beforeSaveResultOfLastSyncCounter uint64
	SaveResultOfLastSyncMock          mPublisherSyncStorageMockSaveResultOfLastSync

	funcUpsertPublisher          func(ctx context.Context, publisher *models.Publisher, updateColumns boil.Columns) (err error)
	inspectFuncUpsertPublisher   func(ctx context.Context, publisher *models.Publisher, updateColumns boil.Columns)
	afterUpsertPublisherCounter  uint64
	beforeUpsertPublisherCounter uint64
	UpsertPublisherMock          mPublisherSyncStorageMockUpsertPublisher
}

// NewPublisherSyncStorageMock returns a mock for db.PublisherSyncStorage
func NewPublisherSyncStorageMock(t minimock.Tester) *PublisherSyncStorageMock {
	m := &PublisherSyncStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.HadLoadingErrorLastTimeMock = mPublisherSyncStorageMockHadLoadingErrorLastTime{mock: m}
	m.HadLoadingErrorLastTimeMock.callArgs = []*PublisherSyncStorageMockHadLoadingErrorLastTimeParams{}

	m.InsertPublisherDomainMock = mPublisherSyncStorageMockInsertPublisherDomain{mock: m}
	m.InsertPublisherDomainMock.callArgs = []*PublisherSyncStorageMockInsertPublisherDomainParams{}

	m.SaveResultOfLastSyncMock = mPublisherSyncStorageMockSaveResultOfLastSync{mock: m}
	m.SaveResultOfLastSyncMock.callArgs = []*PublisherSyncStorageMockSaveResultOfLastSyncParams{}

	m.UpsertPublisherMock = mPublisherSyncStorageMockUpsertPublisher{mock: m}
	m.UpsertPublisherMock.callArgs = []*PublisherSyncStorageMockUpsertPublisherParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPublisherSyncStorageMockHadLoadingErrorLastTime struct {
	mock               *PublisherSyncStorageMock
	defaultExpectation *PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation
	expectations       []*PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation

	callArgs []*PublisherSyncStorageMockHadLoadingErrorLastTimeParams
	mutex    sync.RWMutex
}

// PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation specifies expectation struct of the PublisherSyncStorage.HadLoadingErrorLastTime
type PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation struct {
	mock    *PublisherSyncStorageMock
	params  *PublisherSyncStorageMockHadLoadingErrorLastTimeParams
	results *PublisherSyncStorageMockHadLoadingErrorLastTimeResults
	Counter uint64
}

// PublisherSyncStorageMockHadLoadingErrorLastTimeParams contains parameters of the PublisherSyncStorage.HadLoadingErrorLastTime
type PublisherSyncStorageMockHadLoadingErrorLastTimeParams struct {
	ctx context.Context
	key string
}

// PublisherSyncStorageMockHadLoadingErrorLastTimeResults contains results of the PublisherSyncStorage.HadLoadingErrorLastTime
type PublisherSyncStorageMockHadLoadingErrorLastTimeResults struct {
	b1 bool
}

// Expect sets up expected params for PublisherSyncStorage.HadLoadingErrorLastTime
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Expect(ctx context.Context, key string) *mPublisherSyncStorageMockHadLoadingErrorLastTime {
	if mmHadLoadingErrorLastTime.mock.funcHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("PublisherSyncStorageMock.HadLoadingErrorLastTime mock is already set by Set")
	}

	if mmHadLoadingErrorLastTime.defaultExpectation == nil {
		mmHadLoadingErrorLastTime.defaultExpectation = &PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation{}
	}

	mmHadLoadingErrorLastTime.defaultExpectation.params = &PublisherSyncStorageMockHadLoadingErrorLastTimeParams{ctx, key}
	for _, e := range mmHadLoadingErrorLastTime.expectations {
		if minimock.Equal(e.params, mmHadLoadingErrorLastTime.defaultExpectation.params) {
			mmHadLoadingErrorLastTime.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHadLoadingErrorLastTime.defaultExpectation.params)
		}
	}

	return mmHadLoadingErrorLastTime
}

// Inspect accepts an inspector function that has same arguments as the PublisherSyncStorage.HadLoadingErrorLastTime
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Inspect(f func(ctx context.Context, key string)) *mPublisherSyncStorageMockHadLoadingErrorLastTime {
	if mmHadLoadingErrorLastTime.mock.inspectFuncHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("Inspect function is already set for PublisherSyncStorageMock.HadLoadingErrorLastTime")
	}

	mmHadLoadingErrorLastTime.mock.inspectFuncHadLoadingErrorLastTime = f

	return mmHadLoadingErrorLastTime
}

// Return sets up results that will be returned by PublisherSyncStorage.HadLoadingErrorLastTime
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Return(b1 bool) *PublisherSyncStorageMock {
	if mmHadLoadingErrorLastTime.mock.funcHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("PublisherSyncStorageMock.HadLoadingErrorLastTime mock is already set by Set")
	}

	if mmHadLoadingErrorLastTime.defaultExpectation == nil {
		mmHadLoadingErrorLastTime.defaultExpectation = &PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation{mock: mmHadLoadingErrorLastTime.mock}
	}
	mmHadLoadingErrorLastTime.defaultExpectation.results = &PublisherSyncStorageMockHadLoadingErrorLastTimeResults{b1}
	return mmHadLoadingErrorLastTime.mock
}

// Set uses given function f to mock the PublisherSyncStorage.HadLoadingErrorLastTime method
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Set(f func(ctx context.Context, key string) (b1 bool)) *PublisherSyncStorageMock {
	if mmHadLoadingErrorLastTime.defaultExpectation != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("Default expectation is already set for the PublisherSyncStorage.HadLoadingErrorLastTime method")
	}

	if len(mmHadLoadingErrorLastTime.expectations) > 0 {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("Some expectations are already set for the PublisherSyncStorage.HadLoadingErrorLastTime method")
	}

	mmHadLoadingErrorLastTime.mock.funcHadLoadingErrorLastTime = f
	return mmHadLoadingErrorLastTime.mock
}

// When sets expectation for the PublisherSyncStorage.HadLoadingErrorLastTime which will trigger the result defined by the following
// Then helper
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) When(ctx context.Context, key string) *PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation {
	if mmHadLoadingErrorLastTime.mock.funcHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("PublisherSyncStorageMock.HadLoadingErrorLastTime mock is already set by Set")
	}

	expectation := &PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation{
		mock:   mmHadLoadingErrorLastTime.mock,
		params: &PublisherSyncStorageMockHadLoadingErrorLastTimeParams{ctx, key},
	}
	mmHadLoadingErrorLastTime.expectations = append(mmHadLoadingErrorLastTime.expectations, expectation)
	return expectation
}

// Then sets up PublisherSyncStorage.HadLoadingErrorLastTime return parameters for the expectation previously defined by the When method
func (e *PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation) Then(b1 bool) *PublisherSyncStorageMock {
	e.results = &PublisherSyncStorageMockHadLoadingErrorLastTimeResults{b1}
	return e.mock
}

// HadLoadingErrorLastTime implements db.PublisherSyncStorage
func (mmHadLoadingErrorLastTime *PublisherSyncStorageMock) HadLoadingErrorLastTime(ctx context.Context, key string) (b1 bool) {
	mm_atomic.AddUint64(&mmHadLoadingErrorLastTime.beforeHadLoadingErrorLastTimeCounter, 1)
	defer mm_atomic.AddUint64(&mmHadLoadingErrorLastTime.afterHadLoadingErrorLastTimeCounter, 1)

	if mmHadLoadingErrorLastTime.inspectFuncHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.inspectFuncHadLoadingErrorLastTime(ctx, key)
	}

	mm_params := PublisherSyncStorageMockHadLoadingErrorLastTimeParams{ctx, key}

	// Record call args
	mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.mutex.Lock()
	mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.callArgs = append(mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.callArgs, &mm_params)
	mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.mutex.Unlock()

	for _, e := range mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.defaultExpectation.Counter, 1)
		mm_want := mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.defaultExpectation.params
		mm_got := PublisherSyncStorageMockHadLoadingErrorLastTimeParams{ctx, key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHadLoadingErrorLastTime.t.Errorf("PublisherSyncStorageMock.HadLoadingErrorLastTime got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.defaultExpectation.results
		if mm_results == nil {
			mmHadLoadingErrorLastTime.t.Fatal("No results are set for the PublisherSyncStorageMock.HadLoadingErrorLastTime")
		}
		return (*mm_results).b1
	}
	if mmHadLoadingErrorLastTime.funcHadLoadingErrorLastTime != nil {
		return mmHadLoadingErrorLastTime.funcHadLoadingErrorLastTime(ctx, key)
	}
	mmHadLoadingErrorLastTime.t.Fatalf("Unexpected call to PublisherSyncStorageMock.HadLoadingErrorLastTime. %v %v", ctx, key)
	return
}

// HadLoadingErrorLastTimeAfterCounter returns a count of finished PublisherSyncStorageMock.HadLoadingErrorLastTime invocations
func (mmHadLoadingErrorLastTime *PublisherSyncStorageMock) HadLoadingErrorLastTimeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHadLoadingErrorLastTime.afterHadLoadingErrorLastTimeCounter)
}

// HadLoadingErrorLastTimeBeforeCounter returns a count of PublisherSyncStorageMock.HadLoadingErrorLastTime invocations
func (mmHadLoadingErrorLastTime *PublisherSyncStorageMock) HadLoadingErrorLastTimeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHadLoadingErrorLastTime.beforeHadLoadingErrorLastTimeCounter)
}

// Calls returns a list of arguments used in each call to PublisherSyncStorageMock.HadLoadingErrorLastTime.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Calls() []*PublisherSyncStorageMockHadLoadingErrorLastTimeParams {
	mmHadLoadingErrorLastTime.mutex.RLock()

	argCopy := make([]*PublisherSyncStorageMockHadLoadingErrorLastTimeParams, len(mmHadLoadingErrorLastTime.callArgs))
	copy(argCopy, mmHadLoadingErrorLastTime.callArgs)

	mmHadLoadingErrorLastTime.mutex.RUnlock()

	return argCopy
}

// MinimockHadLoadingErrorLastTimeDone returns true if the count of the HadLoadingErrorLastTime invocations corresponds
// the number of defined expectations
func (m *PublisherSyncStorageMock) MinimockHadLoadingErrorLastTimeDone() bool {
	for _, e := range m.HadLoadingErrorLastTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HadLoadingErrorLastTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHadLoadingErrorLastTimeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHadLoadingErrorLastTime != nil && mm_atomic.LoadUint64(&m.afterHadLoadingErrorLastTimeCounter) < 1 {
		return false
	}
	return true
}

// MinimockHadLoadingErrorLastTimeInspect logs each unmet expectation
func (m *PublisherSyncStorageMock) MinimockHadLoadingErrorLastTimeInspect() {
	for _, e := range m.HadLoadingErrorLastTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.HadLoadingErrorLastTime with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HadLoadingErrorLastTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHadLoadingErrorLastTimeCounter) < 1 {
		if m.HadLoadingErrorLastTimeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherSyncStorageMock.HadLoadingErrorLastTime")
		} else {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.HadLoadingErrorLastTime with params: %#v", *m.HadLoadingErrorLastTimeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHadLoadingErrorLastTime != nil && mm_atomic.LoadUint64(&m.afterHadLoadingErrorLastTimeCounter) < 1 {
		m.t.Error("Expected call to PublisherSyncStorageMock.HadLoadingErrorLastTime")
	}
}

type mPublisherSyncStorageMockInsertPublisherDomain struct {
	mock               *PublisherSyncStorageMock
	defaultExpectation *PublisherSyncStorageMockInsertPublisherDomainExpectation
	expectations       []*PublisherSyncStorageMockInsertPublisherDomainExpectation

	callArgs []*PublisherSyncStorageMockInsertPublisherDomainParams
	mutex    sync.RWMutex
}

// PublisherSyncStorageMockInsertPublisherDomainExpectation specifies expectation struct of the PublisherSyncStorage.InsertPublisherDomain
type PublisherSyncStorageMockInsertPublisherDomainExpectation struct {
	mock    *PublisherSyncStorageMock
	params  *PublisherSyncStorageMockInsertPublisherDomainParams
	results *PublisherSyncStorageMockInsertPublisherDomainResults
	Counter uint64
}

// PublisherSyncStorageMockInsertPublisherDomainParams contains parameters of the PublisherSyncStorage.InsertPublisherDomain
type PublisherSyncStorageMockInsertPublisherDomainParams struct {
	ctx    context.Context
	domain *models.PublisherDomain
}

// PublisherSyncStorageMockInsertPublisherDomainResults contains results of the PublisherSyncStorage.InsertPublisherDomain
type PublisherSyncStorageMockInsertPublisherDomainResults struct {
	err error
}

// Expect sets up expected params for PublisherSyncStorage.InsertPublisherDomain
func (mmInsertPublisherDomain *mPublisherSyncStorageMockInsertPublisherDomain) Expect(ctx context.Context, domain *models.PublisherDomain) *mPublisherSyncStorageMockInsertPublisherDomain {
	if mmInsertPublisherDomain.mock.funcInsertPublisherDomain != nil {
		mmInsertPublisherDomain.mock.t.Fatalf("PublisherSyncStorageMock.InsertPublisherDomain mock is already set by Set")
	}

	if mmInsertPublisherDomain.defaultExpectation == nil {
		mmInsertPublisherDomain.defaultExpectation = &PublisherSyncStorageMockInsertPublisherDomainExpectation{}
	}

	mmInsertPublisherDomain.defaultExpectation.params = &PublisherSyncStorageMockInsertPublisherDomainParams{ctx, domain}
	for _, e := range mmInsertPublisherDomain.expectations {
		if minimock.Equal(e.params, mmInsertPublisherDomain.defaultExpectation.params) {
			mmInsertPublisherDomain.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertPublisherDomain.defaultExpectation.params)
		}
	}

	return mmInsertPublisherDomain
}

// Inspect accepts an inspector function that has same arguments as the PublisherSyncStorage.InsertPublisherDomain
func (mmInsertPublisherDomain *mPublisherSyncStorageMockInsertPublisherDomain) Inspect(f func(ctx context.Context, domain *models.PublisherDomain)) *mPublisherSyncStorageMockInsertPublisherDomain {
	if mmInsertPublisherDomain.mock.inspectFuncInsertPublisherDomain != nil {
		mmInsertPublisherDomain.mock.t.Fatalf("Inspect function is already set for PublisherSyncStorageMock.InsertPublisherDomain")
	}

	mmInsertPublisherDomain.mock.inspectFuncInsertPublisherDomain = f

	return mmInsertPublisherDomain
}

// Return sets up results that will be returned by PublisherSyncStorage.InsertPublisherDomain
func (mmInsertPublisherDomain *mPublisherSyncStorageMockInsertPublisherDomain) Return(err error) *PublisherSyncStorageMock {
	if mmInsertPublisherDomain.mock.funcInsertPublisherDomain != nil {
		mmInsertPublisherDomain.mock.t.Fatalf("PublisherSyncStorageMock.InsertPublisherDomain mock is already set by Set")
	}

	if mmInsertPublisherDomain.defaultExpectation == nil {
		mmInsertPublisherDomain.defaultExpectation = &PublisherSyncStorageMockInsertPublisherDomainExpectation{mock: mmInsertPublisherDomain.mock}
	}
	mmInsertPublisherDomain.defaultExpectation.results = &PublisherSyncStorageMockInsertPublisherDomainResults{err}
	return mmInsertPublisherDomain.mock
}

// Set uses given function f to mock the PublisherSyncStorage.InsertPublisherDomain method
func (mmInsertPublisherDomain *mPublisherSyncStorageMockInsertPublisherDomain) Set(f func(ctx context.Context, domain *models.PublisherDomain) (err error)) *PublisherSyncStorageMock {
	if mmInsertPublisherDomain.defaultExpectation != nil {
		mmInsertPublisherDomain.mock.t.Fatalf("Default expectation is already set for the PublisherSyncStorage.InsertPublisherDomain method")
	}

	if len(mmInsertPublisherDomain.expectations) > 0 {
		mmInsertPublisherDomain.mock.t.Fatalf("Some expectations are already set for the PublisherSyncStorage.InsertPublisherDomain method")
	}

	mmInsertPublisherDomain.mock.funcInsertPublisherDomain = f
	return mmInsertPublisherDomain.mock
}

// When sets expectation for the PublisherSyncStorage.InsertPublisherDomain which will trigger the result defined by the following
// Then helper
func (mmInsertPublisherDomain *mPublisherSyncStorageMockInsertPublisherDomain) When(ctx context.Context, domain *models.PublisherDomain) *PublisherSyncStorageMockInsertPublisherDomainExpectation {
	if mmInsertPublisherDomain.mock.funcInsertPublisherDomain != nil {
		mmInsertPublisherDomain.mock.t.Fatalf("PublisherSyncStorageMock.InsertPublisherDomain mock is already set by Set")
	}

	expectation := &PublisherSyncStorageMockInsertPublisherDomainExpectation{
		mock:   mmInsertPublisherDomain.mock,
		params: &PublisherSyncStorageMockInsertPublisherDomainParams{ctx, domain},
	}
	mmInsertPublisherDomain.expectations = append(mmInsertPublisherDomain.expectations, expectation)
	return expectation
}

// Then sets up PublisherSyncStorage.InsertPublisherDomain return parameters for the expectation previously defined by the When method
func (e *PublisherSyncStorageMockInsertPublisherDomainExpectation) Then(err error) *PublisherSyncStorageMock {
	e.results = &PublisherSyncStorageMockInsertPublisherDomainResults{err}
	return e.mock
}

// InsertPublisherDomain implements db.PublisherSyncStorage
func (mmInsertPublisherDomain *PublisherSyncStorageMock) InsertPublisherDomain(ctx context.Context, domain *models.PublisherDomain) (err error) {
	mm_atomic.AddUint64(&mmInsertPublisherDomain.beforeInsertPublisherDomainCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertPublisherDomain.afterInsertPublisherDomainCounter, 1)

	if mmInsertPublisherDomain.inspectFuncInsertPublisherDomain != nil {
		mmInsertPublisherDomain.inspectFuncInsertPublisherDomain(ctx, domain)
	}

	mm_params := PublisherSyncStorageMockInsertPublisherDomainParams{ctx, domain}

	// Record call args
	mmInsertPublisherDomain.InsertPublisherDomainMock.mutex.Lock()
	mmInsertPublisherDomain.InsertPublisherDomainMock.callArgs = append(mmInsertPublisherDomain.InsertPublisherDomainMock.callArgs, &mm_params)
	mmInsertPublisherDomain.InsertPublisherDomainMock.mutex.Unlock()

	for _, e := range mmInsertPublisherDomain.InsertPublisherDomainMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertPublisherDomain.InsertPublisherDomainMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertPublisherDomain.InsertPublisherDomainMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertPublisherDomain.InsertPublisherDomainMock.defaultExpectation.params
		mm_got := PublisherSyncStorageMockInsertPublisherDomainParams{ctx, domain}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertPublisherDomain.t.Errorf("PublisherSyncStorageMock.InsertPublisherDomain got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertPublisherDomain.InsertPublisherDomainMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertPublisherDomain.t.Fatal("No results are set for the PublisherSyncStorageMock.InsertPublisherDomain")
		}
		return (*mm_results).err
	}
	if mmInsertPublisherDomain.funcInsertPublisherDomain != nil {
		return mmInsertPublisherDomain.funcInsertPublisherDomain(ctx, domain)
	}
	mmInsertPublisherDomain.t.Fatalf("Unexpected call to PublisherSyncStorageMock.InsertPublisherDomain. %v %v", ctx, domain)
	return
}

// InsertPublisherDomainAfterCounter returns a count of finished PublisherSyncStorageMock.InsertPublisherDomain invocations
func (mmInsertPublisherDomain *PublisherSyncStorageMock) InsertPublisherDomainAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertPublisherDomain.afterInsertPublisherDomainCounter)
}

// InsertPublisherDomainBeforeCounter returns a count of PublisherSyncStorageMock.InsertPublisherDomain invocations
func (mmInsertPublisherDomain *PublisherSyncStorageMock) InsertPublisherDomainBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertPublisherDomain.beforeInsertPublisherDomainCounter)
}

// Calls returns a list of arguments used in each call to PublisherSyncStorageMock.InsertPublisherDomain.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertPublisherDomain *mPublisherSyncStorageMockInsertPublisherDomain) Calls() []*PublisherSyncStorageMockInsertPublisherDomainParams {
	mmInsertPublisherDomain.mutex.RLock()

	argCopy := make([]*PublisherSyncStorageMockInsertPublisherDomainParams, len(mmInsertPublisherDomain.callArgs))
	copy(argCopy, mmInsertPublisherDomain.callArgs)

	mmInsertPublisherDomain.mutex.RUnlock()

	return argCopy
}

// MinimockInsertPublisherDomainDone returns true if the count of the InsertPublisherDomain invocations corresponds
// the number of defined expectations
func (m *PublisherSyncStorageMock) MinimockInsertPublisherDomainDone() bool {
	for _, e := range m.InsertPublisherDomainMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertPublisherDomainMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertPublisherDomainCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertPublisherDomain != nil && mm_atomic.LoadUint64(&m.afterInsertPublisherDomainCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertPublisherDomainInspect logs each unmet expectation
func (m *PublisherSyncStorageMock) MinimockInsertPublisherDomainInspect() {
	for _, e := range m.InsertPublisherDomainMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.InsertPublisherDomain with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertPublisherDomainMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertPublisherDomainCounter) < 1 {
		if m.InsertPublisherDomainMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherSyncStorageMock.InsertPublisherDomain")
		} else {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.InsertPublisherDomain with params: %#v", *m.InsertPublisherDomainMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertPublisherDomain != nil && mm_atomic.LoadUint64(&m.afterInsertPublisherDomainCounter) < 1 {
		m.t.Error("Expected call to PublisherSyncStorageMock.InsertPublisherDomain")
	}
}

type mPublisherSyncStorageMockSaveResultOfLastSync struct {
	mock               *PublisherSyncStorageMock
	defaultExpectation *PublisherSyncStorageMockSaveResultOfLastSyncExpectation
	expectations       []*PublisherSyncStorageMockSaveResultOfLastSyncExpectation

	callArgs []*PublisherSyncStorageMockSaveResultOfLastSyncParams
	mutex    sync.RWMutex
}

// PublisherSyncStorageMockSaveResultOfLastSyncExpectation specifies expectation struct of the PublisherSyncStorage.SaveResultOfLastSync
type PublisherSyncStorageMockSaveResultOfLastSyncExpectation struct {
	mock    *PublisherSyncStorageMock
	params  *PublisherSyncStorageMockSaveResultOfLastSyncParams
	results *PublisherSyncStorageMockSaveResultOfLastSyncResults
	Counter uint64
}

// PublisherSyncStorageMockSaveResultOfLastSyncParams contains parameters of the PublisherSyncStorage.SaveResultOfLastSync
type PublisherSyncStorageMockSaveResultOfLastSyncParams struct {
	ctx       context.Context
	key       string
	hasErrors bool
}

// PublisherSyncStorageMockSaveResultOfLastSyncResults contains results of the PublisherSyncStorage.SaveResultOfLastSync
type PublisherSyncStorageMockSaveResultOfLastSyncResults struct {
	err error
}

// Expect sets up expected params for PublisherSyncStorage.SaveResultOfLastSync
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Expect(ctx context.Context, key string, hasErrors bool) *mPublisherSyncStorageMockSaveResultOfLastSync {
	if mmSaveResultOfLastSync.mock.funcSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("PublisherSyncStorageMock.SaveResultOfLastSync mock is already set by Set")
	}

	if mmSaveResultOfLastSync.defaultExpectation == nil {
		mmSaveResultOfLastSync.defaultExpectation = &PublisherSyncStorageMockSaveResultOfLastSyncExpectation{}
	}

	mmSaveResultOfLastSync.defaultExpectation.params = &PublisherSyncStorageMockSaveResultOfLastSyncParams{ctx, key, hasErrors}
	for _, e := range mmSaveResultOfLastSync.expectations {
		if minimock.Equal(e.params, mmSaveResultOfLastSync.defaultExpectation.params) {
			mmSaveResultOfLastSync.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveResultOfLastSync.defaultExpectation.params)
		}
	}

	return mmSaveResultOfLastSync
}

// Inspect accepts an inspector function that has same arguments as the PublisherSyncStorage.SaveResultOfLastSync
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Inspect(f func(ctx context.Context, key string, hasErrors bool)) *mPublisherSyncStorageMockSaveResultOfLastSync {
	if mmSaveResultOfLastSync.mock.inspectFuncSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("Inspect function is already set for PublisherSyncStorageMock.SaveResultOfLastSync")
	}

	mmSaveResultOfLastSync.mock.inspectFuncSaveResultOfLastSync = f

	return mmSaveResultOfLastSync
}

// Return sets up results that will be returned by PublisherSyncStorage.SaveResultOfLastSync
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Return(err error) *PublisherSyncStorageMock {
	if mmSaveResultOfLastSync.mock.funcSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("PublisherSyncStorageMock.SaveResultOfLastSync mock is already set by Set")
	}

	if mmSaveResultOfLastSync.defaultExpectation == nil {
		mmSaveResultOfLastSync.defaultExpectation = &PublisherSyncStorageMockSaveResultOfLastSyncExpectation{mock: mmSaveResultOfLastSync.mock}
	}
	mmSaveResultOfLastSync.defaultExpectation.results = &PublisherSyncStorageMockSaveResultOfLastSyncResults{err}
	return mmSaveResultOfLastSync.mock
}

// Set uses given function f to mock the PublisherSyncStorage.SaveResultOfLastSync method
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Set(f func(ctx context.Context, key string, hasErrors bool) (err error)) *PublisherSyncStorageMock {
	if mmSaveResultOfLastSync.defaultExpectation != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("Default expectation is already set for the PublisherSyncStorage.SaveResultOfLastSync method")
	}

	if len(mmSaveResultOfLastSync.expectations) > 0 {
		mmSaveResultOfLastSync.mock.t.Fatalf("Some expectations are already set for the PublisherSyncStorage.SaveResultOfLastSync method")
	}

	mmSaveResultOfLastSync.mock.funcSaveResultOfLastSync = f
	return mmSaveResultOfLastSync.mock
}

// When sets expectation for the PublisherSyncStorage.SaveResultOfLastSync which will trigger the result defined by the following
// Then helper
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) When(ctx context.Context, key string, hasErrors bool) *PublisherSyncStorageMockSaveResultOfLastSyncExpectation {
	if mmSaveResultOfLastSync.mock.funcSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("PublisherSyncStorageMock.SaveResultOfLastSync mock is already set by Set")
	}

	expectation := &PublisherSyncStorageMockSaveResultOfLastSyncExpectation{
		mock:   mmSaveResultOfLastSync.mock,
		params: &PublisherSyncStorageMockSaveResultOfLastSyncParams{ctx, key, hasErrors},
	}
	mmSaveResultOfLastSync.expectations = append(mmSaveResultOfLastSync.expectations, expectation)
	return expectation
}

// Then sets up PublisherSyncStorage.SaveResultOfLastSync return parameters for the expectation previously defined by the When method
func (e *PublisherSyncStorageMockSaveResultOfLastSyncExpectation) Then(err error) *PublisherSyncStorageMock {
	e.results = &PublisherSyncStorageMockSaveResultOfLastSyncResults{err}
	return e.mock
}

// SaveResultOfLastSync implements db.PublisherSyncStorage
func (mmSaveResultOfLastSync *PublisherSyncStorageMock) SaveResultOfLastSync(ctx context.Context, key string, hasErrors bool) (err error) {
	mm_atomic.AddUint64(&mmSaveResultOfLastSync.beforeSaveResultOfLastSyncCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveResultOfLastSync.afterSaveResultOfLastSyncCounter, 1)

	if mmSaveResultOfLastSync.inspectFuncSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.inspectFuncSaveResultOfLastSync(ctx, key, hasErrors)
	}

	mm_params := PublisherSyncStorageMockSaveResultOfLastSyncParams{ctx, key, hasErrors}

	// Record call args
	mmSaveResultOfLastSync.SaveResultOfLastSyncMock.mutex.Lock()
	mmSaveResultOfLastSync.SaveResultOfLastSyncMock.callArgs = append(mmSaveResultOfLastSync.SaveResultOfLastSyncMock.callArgs, &mm_params)
	mmSaveResultOfLastSync.SaveResultOfLastSyncMock.mutex.Unlock()

	for _, e := range mmSaveResultOfLastSync.SaveResultOfLastSyncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveResultOfLastSync.SaveResultOfLastSyncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveResultOfLastSync.SaveResultOfLastSyncMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveResultOfLastSync.SaveResultOfLastSyncMock.defaultExpectation.params
		mm_got := PublisherSyncStorageMockSaveResultOfLastSyncParams{ctx, key, hasErrors}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveResultOfLastSync.t.Errorf("PublisherSyncStorageMock.SaveResultOfLastSync got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveResultOfLastSync.SaveResultOfLastSyncMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveResultOfLastSync.t.Fatal("No results are set for the PublisherSyncStorageMock.SaveResultOfLastSync")
		}
		return (*mm_results).err
	}
	if mmSaveResultOfLastSync.funcSaveResultOfLastSync != nil {
		return mmSaveResultOfLastSync.funcSaveResultOfLastSync(ctx, key, hasErrors)
	}
	mmSaveResultOfLastSync.t.Fatalf("Unexpected call to PublisherSyncStorageMock.SaveResultOfLastSync. %v %v %v", ctx, key, hasErrors)
	return
}

// SaveResultOfLastSyncAfterCounter returns a count of finished PublisherSyncStorageMock.SaveResultOfLastSync invocations
func (mmSaveResultOfLastSync *PublisherSyncStorageMock) SaveResultOfLastSyncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveResultOfLastSync.afterSaveResultOfLastSyncCounter)
}

// SaveResultOfLastSyncBeforeCounter returns a count of PublisherSyncStorageMock.SaveResultOfLastSync invocations
func (mmSaveResultOfLastSync *PublisherSyncStorageMock) SaveResultOfLastSyncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveResultOfLastSync.beforeSaveResultOfLastSyncCounter)
}

// Calls returns a list of arguments used in each call to PublisherSyncStorageMock.SaveResultOfLastSync.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Calls() []*PublisherSyncStorageMockSaveResultOfLastSyncParams {
	mmSaveResultOfLastSync.mutex.RLock()

	argCopy := make([]*PublisherSyncStorageMockSaveResultOfLastSyncParams, len(mmSaveResultOfLastSync.callArgs))
	copy(argCopy, mmSaveResultOfLastSync.callArgs)

	mmSaveResultOfLastSync.mutex.RUnlock()

	return argCopy
}

// MinimockSaveResultOfLastSyncDone returns true if the count of the SaveResultOfLastSync invocations corresponds
// the number of defined expectations
func (m *PublisherSyncStorageMock) MinimockSaveResultOfLastSyncDone() bool {
	for _, e := range m.SaveResultOfLastSyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveResultOfLastSyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveResultOfLastSyncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveResultOfLastSync != nil && mm_atomic.LoadUint64(&m.afterSaveResultOfLastSyncCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveResultOfLastSyncInspect logs each unmet expectation
func (m *PublisherSyncStorageMock) MinimockSaveResultOfLastSyncInspect() {
	for _, e := range m.SaveResultOfLastSyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.SaveResultOfLastSync with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveResultOfLastSyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveResultOfLastSyncCounter) < 1 {
		if m.SaveResultOfLastSyncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherSyncStorageMock.SaveResultOfLastSync")
		} else {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.SaveResultOfLastSync with params: %#v", *m.SaveResultOfLastSyncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveResultOfLastSync != nil && mm_atomic.LoadUint64(&m.afterSaveResultOfLastSyncCounter) < 1 {
		m.t.Error("Expected call to PublisherSyncStorageMock.SaveResultOfLastSync")
	}
}

type mPublisherSyncStorageMockUpsertPublisher struct {
	mock               *PublisherSyncStorageMock
	defaultExpectation *PublisherSyncStorageMockUpsertPublisherExpectation
	expectations       []*PublisherSyncStorageMockUpsertPublisherExpectation

	callArgs []*PublisherSyncStorageMockUpsertPublisherParams
	mutex    sync.RWMutex
}

// PublisherSyncStorageMockUpsertPublisherExpectation specifies expectation struct of the PublisherSyncStorage.UpsertPublisher
type PublisherSyncStorageMockUpsertPublisherExpectation struct {
	mock    *PublisherSyncStorageMock
	params  *PublisherSyncStorageMockUpsertPublisherParams
	results *PublisherSyncStorageMockUpsertPublisherResults
	Counter uint64
}

// PublisherSyncStorageMockUpsertPublisherParams contains parameters of the PublisherSyncStorage.UpsertPublisher
type PublisherSyncStorageMockUpsertPublisherParams struct {
	ctx           context.Context
	publisher     *models.Publisher
	updateColumns boil.Columns
}

// PublisherSyncStorageMockUpsertPublisherResults contains results of the PublisherSyncStorage.UpsertPublisher
type PublisherSyncStorageMockUpsertPublisherResults struct {
	err error
}

// Expect sets up expected params for PublisherSyncStorage.UpsertPublisher
func (mmUpsertPublisher *mPublisherSyncStorageMockUpsertPublisher) Expect(ctx context.Context, publisher *models.Publisher, updateColumns boil.Columns) *mPublisherSyncStorageMockUpsertPublisher {
	if mmUpsertPublisher.mock.funcUpsertPublisher != nil {
		mmUpsertPublisher.mock.t.Fatalf("PublisherSyncStorageMock.UpsertPublisher mock is already set by Set")
	}

	if mmUpsertPublisher.defaultExpectation == nil {
		mmUpsertPublisher.defaultExpectation = &PublisherSyncStorageMockUpsertPublisherExpectation{}
	}

	mmUpsertPublisher.defaultExpectation.params = &PublisherSyncStorageMockUpsertPublisherParams{ctx, publisher, updateColumns}
	for _, e := range mmUpsertPublisher.expectations {
		if minimock.Equal(e.params, mmUpsertPublisher.defaultExpectation.params) {
			mmUpsertPublisher.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertPublisher.defaultExpectation.params)
		}
	}

	return mmUpsertPublisher
}

// Inspect accepts an inspector function that has same arguments as the PublisherSyncStorage.UpsertPublisher
func (mmUpsertPublisher *mPublisherSyncStorageMockUpsertPublisher) Inspect(f func(ctx context.Context, publisher *models.Publisher, updateColumns boil.Columns)) *mPublisherSyncStorageMockUpsertPublisher {
	if mmUpsertPublisher.mock.inspectFuncUpsertPublisher != nil {
		mmUpsertPublisher.mock.t.Fatalf("Inspect function is already set for PublisherSyncStorageMock.UpsertPublisher")
	}

	mmUpsertPublisher.mock.inspectFuncUpsertPublisher = f

	return mmUpsertPublisher
}

// Return sets up results that will be returned by PublisherSyncStorage.UpsertPublisher
func (mmUpsertPublisher *mPublisherSyncStorageMockUpsertPublisher) Return(err error) *PublisherSyncStorageMock {
	if mmUpsertPublisher.mock.funcUpsertPublisher != nil {
		mmUpsertPublisher.mock.t.Fatalf("PublisherSyncStorageMock.UpsertPublisher mock is already set by Set")
	}

	if mmUpsertPublisher.defaultExpectation == nil {
		mmUpsertPublisher.defaultExpectation = &PublisherSyncStorageMockUpsertPublisherExpectation{mock: mmUpsertPublisher.mock}
	}
	mmUpsertPublisher.defaultExpectation.results = &PublisherSyncStorageMockUpsertPublisherResults{err}
	return mmUpsertPublisher.mock
}

// Set uses given function f to mock the PublisherSyncStorage.UpsertPublisher method
func (mmUpsertPublisher *mPublisherSyncStorageMockUpsertPublisher) Set(f func(ctx context.Context, publisher *models.Publisher, updateColumns boil.Columns) (err error)) *PublisherSyncStorageMock {
	if mmUpsertPublisher.defaultExpectation != nil {
		mmUpsertPublisher.mock.t.Fatalf("Default expectation is already set for the PublisherSyncStorage.UpsertPublisher method")
	}

	if len(mmUpsertPublisher.expectations) > 0 {
		mmUpsertPublisher.mock.t.Fatalf("Some expectations are already set for the PublisherSyncStorage.UpsertPublisher method")
	}

	mmUpsertPublisher.mock.funcUpsertPublisher = f
	return mmUpsertPublisher.mock
}

// When sets expectation for the PublisherSyncStorage.UpsertPublisher which will trigger the result defined by the following
// Then helper
func (mmUpsertPublisher *mPublisherSyncStorageMockUpsertPublisher) When(ctx context.Context, publisher *models.Publisher, updateColumns boil.Columns) *PublisherSyncStorageMockUpsertPublisherExpectation {
	if mmUpsertPublisher.mock.funcUpsertPublisher != nil {
		mmUpsertPublisher.mock.t.Fatalf("PublisherSyncStorageMock.UpsertPublisher mock is already set by Set")
	}

	expectation := &PublisherSyncStorageMockUpsertPublisherExpectation{
		mock:   mmUpsertPublisher.mock,
		params: &PublisherSyncStorageMockUpsertPublisherParams{ctx, publisher, updateColumns},
	}
	mmUpsertPublisher.expectations = append(mmUpsertPublisher.expectations, expectation)
	return expectation
}

// Then sets up PublisherSyncStorage.UpsertPublisher return parameters for the expectation previously defined by the When method
func (e *PublisherSyncStorageMockUpsertPublisherExpectation) Then(err error) *PublisherSyncStorageMock {
	e.results = &PublisherSyncStorageMockUpsertPublisherResults{err}
	return e.mock
}

// UpsertPublisher implements db.PublisherSyncStorage
func (mmUpsertPublisher *PublisherSyncStorageMock) UpsertPublisher(ctx context.Context, publisher *models.Publisher, updateColumns boil.Columns) (err error) {
	mm_atomic.AddUint64(&mmUpsertPublisher.beforeUpsertPublisherCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertPublisher.afterUpsertPublisherCounter, 1)

	if mmUpsertPublisher.inspectFuncUpsertPublisher != nil {
		mmUpsertPublisher.inspectFuncUpsertPublisher(ctx, publisher, updateColumns)
	}

	mm_params := PublisherSyncStorageMockUpsertPublisherParams{ctx, publisher, updateColumns}

	// Record call args
	mmUpsertPublisher.UpsertPublisherMock.mutex.Lock()
	mmUpsertPublisher.UpsertPublisherMock.callArgs = append(mmUpsertPublisher.UpsertPublisherMock.callArgs, &mm_params)
	mmUpsertPublisher.UpsertPublisherMock.mutex.Unlock()

	for _, e := range mmUpsertPublisher.UpsertPublisherMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertPublisher.UpsertPublisherMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertPublisher.UpsertPublisherMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertPublisher.UpsertPublisherMock.defaultExpectation.params
		mm_got := PublisherSyncStorageMockUpsertPublisherParams{ctx, publisher, updateColumns}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertPublisher.t.Errorf("PublisherSyncStorageMock.UpsertPublisher got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertPublisher.UpsertPublisherMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertPublisher.t.Fatal("No results are set for the PublisherSyncStorageMock.UpsertPublisher")
		}
		return (*mm_results).err
	}
	if mmUpsertPublisher.funcUpsertPublisher != nil {
		return mmUpsertPublisher.funcUpsertPublisher(ctx, publisher, updateColumns)
	}
	mmUpsertPublisher.t.Fatalf("Unexpected call to PublisherSyncStorageMock.UpsertPublisher. %v %v %v", ctx, publisher, updateColumns)
	return
}

// UpsertPublisherAfterCounter returns a count of finished PublisherSyncStorageMock.UpsertPublisher invocations
func (mmUpsertPublisher *PublisherSyncStorageMock) UpsertPublisherAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertPublisher.afterUpsertPublisherCounter)
}

// UpsertPublisherBeforeCounter returns a count of PublisherSyncStorageMock.UpsertPublisher invocations
func (mmUpsertPublisher *PublisherSyncStorageMock) UpsertPublisherBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertPublisher.beforeUpsertPublisherCounter)
}

// Calls returns a list of arguments used in each call to PublisherSyncStorageMock.UpsertPublisher.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertPublisher *mPublisherSyncStorageMockUpsertPublisher) Calls() []*PublisherSyncStorageMockUpsertPublisherParams {
	mmUpsertPublisher.mutex.RLock()

	argCopy := make([]*PublisherSyncStorageMockUpsertPublisherParams, len(mmUpsertPublisher.callArgs))
	copy(argCopy, mmUpsertPublisher.callArgs)

	mmUpsertPublisher.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertPublisherDone returns true if the count of the UpsertPublisher invocations corresponds
// the number of defined expectations
func (m *PublisherSyncStorageMock) MinimockUpsertPublisherDone() bool {
	for _, e := range m.UpsertPublisherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertPublisherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertPublisherCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertPublisher != nil && mm_atomic.LoadUint64(&m.afterUpsertPublisherCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertPublisherInspect logs each unmet expectation
func (m *PublisherSyncStorageMock) MinimockUpsertPublisherInspect() {
	for _, e := range m.UpsertPublisherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.UpsertPublisher with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertPublisherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertPublisherCounter) < 1 {
		if m.UpsertPublisherMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherSyncStorageMock.UpsertPublisher")
		} else {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.UpsertPublisher with params: %#v", *m.UpsertPublisherMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertPublisher != nil && mm_atomic.LoadUint64(&m.afterUpsertPublisherCounter) < 1 {
		m.t.Error("Expected call to PublisherSyncStorageMock.UpsertPublisher")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PublisherSyncStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockHadLoadingErrorLastTimeInspect()

			m.MinimockInsertPublisherDomainInspect()

			m.MinimockSaveResultOfLastSyncInspect()

			m.MinimockUpsertPublisherInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PublisherSyncStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PublisherSyncStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockHadLoadingErrorLastTimeDone() &&
		m.MinimockInsertPublisherDomainDone() &&
		m.MinimockSaveResultOfLastSyncDone() &&
		m.MinimockUpsertPublisherDone()
}
