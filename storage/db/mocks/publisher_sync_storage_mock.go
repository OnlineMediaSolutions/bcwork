// Code generated by http://github.com/gojuno/minimock (v3.3.6). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m6yf/bcwork/storage/db.PublisherSyncStorage -o publisher_sync_storage_mock.go -n PublisherSyncStorageMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/m6yf/bcwork/models"
	"github.com/volatiletech/sqlboiler/v4/boil"
)

// PublisherSyncStorageMock implements db.PublisherSyncStorage
type PublisherSyncStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcHadLoadingErrorLastTime          func(ctx context.Context, key string) (b1 bool)
	inspectFuncHadLoadingErrorLastTime   func(ctx context.Context, key string)
	afterHadLoadingErrorLastTimeCounter  uint64
	beforeHadLoadingErrorLastTimeCounter uint64
	HadLoadingErrorLastTimeMock          mPublisherSyncStorageMockHadLoadingErrorLastTime

	funcSaveResultOfLastSync          func(ctx context.Context, key string, hasErrors bool) (err error)
	inspectFuncSaveResultOfLastSync   func(ctx context.Context, key string, hasErrors bool)
	afterSaveResultOfLastSyncCounter  uint64
	beforeSaveResultOfLastSyncCounter uint64
	SaveResultOfLastSyncMock          mPublisherSyncStorageMockSaveResultOfLastSync

	funcUpsertPublisherAndDomains          func(ctx context.Context, publisher *models.Publisher, domains []*models.PublisherDomain, updateColumns boil.Columns) (err error)
	inspectFuncUpsertPublisherAndDomains   func(ctx context.Context, publisher *models.Publisher, domains []*models.PublisherDomain, updateColumns boil.Columns)
	afterUpsertPublisherAndDomainsCounter  uint64
	beforeUpsertPublisherAndDomainsCounter uint64
	UpsertPublisherAndDomainsMock          mPublisherSyncStorageMockUpsertPublisherAndDomains
}

// NewPublisherSyncStorageMock returns a mock for db.PublisherSyncStorage
func NewPublisherSyncStorageMock(t minimock.Tester) *PublisherSyncStorageMock {
	m := &PublisherSyncStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.HadLoadingErrorLastTimeMock = mPublisherSyncStorageMockHadLoadingErrorLastTime{mock: m}
	m.HadLoadingErrorLastTimeMock.callArgs = []*PublisherSyncStorageMockHadLoadingErrorLastTimeParams{}

	m.SaveResultOfLastSyncMock = mPublisherSyncStorageMockSaveResultOfLastSync{mock: m}
	m.SaveResultOfLastSyncMock.callArgs = []*PublisherSyncStorageMockSaveResultOfLastSyncParams{}

	m.UpsertPublisherAndDomainsMock = mPublisherSyncStorageMockUpsertPublisherAndDomains{mock: m}
	m.UpsertPublisherAndDomainsMock.callArgs = []*PublisherSyncStorageMockUpsertPublisherAndDomainsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPublisherSyncStorageMockHadLoadingErrorLastTime struct {
	mock               *PublisherSyncStorageMock
	defaultExpectation *PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation
	expectations       []*PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation

	callArgs []*PublisherSyncStorageMockHadLoadingErrorLastTimeParams
	mutex    sync.RWMutex
}

// PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation specifies expectation struct of the PublisherSyncStorage.HadLoadingErrorLastTime
type PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation struct {
	mock    *PublisherSyncStorageMock
	params  *PublisherSyncStorageMockHadLoadingErrorLastTimeParams
	results *PublisherSyncStorageMockHadLoadingErrorLastTimeResults
	Counter uint64
}

// PublisherSyncStorageMockHadLoadingErrorLastTimeParams contains parameters of the PublisherSyncStorage.HadLoadingErrorLastTime
type PublisherSyncStorageMockHadLoadingErrorLastTimeParams struct {
	ctx context.Context
	key string
}

// PublisherSyncStorageMockHadLoadingErrorLastTimeResults contains results of the PublisherSyncStorage.HadLoadingErrorLastTime
type PublisherSyncStorageMockHadLoadingErrorLastTimeResults struct {
	b1 bool
}

// Expect sets up expected params for PublisherSyncStorage.HadLoadingErrorLastTime
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Expect(ctx context.Context, key string) *mPublisherSyncStorageMockHadLoadingErrorLastTime {
	if mmHadLoadingErrorLastTime.mock.funcHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("PublisherSyncStorageMock.HadLoadingErrorLastTime mock is already set by Set")
	}

	if mmHadLoadingErrorLastTime.defaultExpectation == nil {
		mmHadLoadingErrorLastTime.defaultExpectation = &PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation{}
	}

	mmHadLoadingErrorLastTime.defaultExpectation.params = &PublisherSyncStorageMockHadLoadingErrorLastTimeParams{ctx, key}
	for _, e := range mmHadLoadingErrorLastTime.expectations {
		if minimock.Equal(e.params, mmHadLoadingErrorLastTime.defaultExpectation.params) {
			mmHadLoadingErrorLastTime.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHadLoadingErrorLastTime.defaultExpectation.params)
		}
	}

	return mmHadLoadingErrorLastTime
}

// Inspect accepts an inspector function that has same arguments as the PublisherSyncStorage.HadLoadingErrorLastTime
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Inspect(f func(ctx context.Context, key string)) *mPublisherSyncStorageMockHadLoadingErrorLastTime {
	if mmHadLoadingErrorLastTime.mock.inspectFuncHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("Inspect function is already set for PublisherSyncStorageMock.HadLoadingErrorLastTime")
	}

	mmHadLoadingErrorLastTime.mock.inspectFuncHadLoadingErrorLastTime = f

	return mmHadLoadingErrorLastTime
}

// Return sets up results that will be returned by PublisherSyncStorage.HadLoadingErrorLastTime
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Return(b1 bool) *PublisherSyncStorageMock {
	if mmHadLoadingErrorLastTime.mock.funcHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("PublisherSyncStorageMock.HadLoadingErrorLastTime mock is already set by Set")
	}

	if mmHadLoadingErrorLastTime.defaultExpectation == nil {
		mmHadLoadingErrorLastTime.defaultExpectation = &PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation{mock: mmHadLoadingErrorLastTime.mock}
	}
	mmHadLoadingErrorLastTime.defaultExpectation.results = &PublisherSyncStorageMockHadLoadingErrorLastTimeResults{b1}
	return mmHadLoadingErrorLastTime.mock
}

// Set uses given function f to mock the PublisherSyncStorage.HadLoadingErrorLastTime method
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Set(f func(ctx context.Context, key string) (b1 bool)) *PublisherSyncStorageMock {
	if mmHadLoadingErrorLastTime.defaultExpectation != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("Default expectation is already set for the PublisherSyncStorage.HadLoadingErrorLastTime method")
	}

	if len(mmHadLoadingErrorLastTime.expectations) > 0 {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("Some expectations are already set for the PublisherSyncStorage.HadLoadingErrorLastTime method")
	}

	mmHadLoadingErrorLastTime.mock.funcHadLoadingErrorLastTime = f
	return mmHadLoadingErrorLastTime.mock
}

// When sets expectation for the PublisherSyncStorage.HadLoadingErrorLastTime which will trigger the result defined by the following
// Then helper
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) When(ctx context.Context, key string) *PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation {
	if mmHadLoadingErrorLastTime.mock.funcHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.mock.t.Fatalf("PublisherSyncStorageMock.HadLoadingErrorLastTime mock is already set by Set")
	}

	expectation := &PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation{
		mock:   mmHadLoadingErrorLastTime.mock,
		params: &PublisherSyncStorageMockHadLoadingErrorLastTimeParams{ctx, key},
	}
	mmHadLoadingErrorLastTime.expectations = append(mmHadLoadingErrorLastTime.expectations, expectation)
	return expectation
}

// Then sets up PublisherSyncStorage.HadLoadingErrorLastTime return parameters for the expectation previously defined by the When method
func (e *PublisherSyncStorageMockHadLoadingErrorLastTimeExpectation) Then(b1 bool) *PublisherSyncStorageMock {
	e.results = &PublisherSyncStorageMockHadLoadingErrorLastTimeResults{b1}
	return e.mock
}

// HadLoadingErrorLastTime implements db.PublisherSyncStorage
func (mmHadLoadingErrorLastTime *PublisherSyncStorageMock) HadLoadingErrorLastTime(ctx context.Context, key string) (b1 bool) {
	mm_atomic.AddUint64(&mmHadLoadingErrorLastTime.beforeHadLoadingErrorLastTimeCounter, 1)
	defer mm_atomic.AddUint64(&mmHadLoadingErrorLastTime.afterHadLoadingErrorLastTimeCounter, 1)

	if mmHadLoadingErrorLastTime.inspectFuncHadLoadingErrorLastTime != nil {
		mmHadLoadingErrorLastTime.inspectFuncHadLoadingErrorLastTime(ctx, key)
	}

	mm_params := PublisherSyncStorageMockHadLoadingErrorLastTimeParams{ctx, key}

	// Record call args
	mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.mutex.Lock()
	mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.callArgs = append(mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.callArgs, &mm_params)
	mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.mutex.Unlock()

	for _, e := range mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.defaultExpectation.Counter, 1)
		mm_want := mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.defaultExpectation.params
		mm_got := PublisherSyncStorageMockHadLoadingErrorLastTimeParams{ctx, key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHadLoadingErrorLastTime.t.Errorf("PublisherSyncStorageMock.HadLoadingErrorLastTime got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHadLoadingErrorLastTime.HadLoadingErrorLastTimeMock.defaultExpectation.results
		if mm_results == nil {
			mmHadLoadingErrorLastTime.t.Fatal("No results are set for the PublisherSyncStorageMock.HadLoadingErrorLastTime")
		}
		return (*mm_results).b1
	}
	if mmHadLoadingErrorLastTime.funcHadLoadingErrorLastTime != nil {
		return mmHadLoadingErrorLastTime.funcHadLoadingErrorLastTime(ctx, key)
	}
	mmHadLoadingErrorLastTime.t.Fatalf("Unexpected call to PublisherSyncStorageMock.HadLoadingErrorLastTime. %v %v", ctx, key)
	return
}

// HadLoadingErrorLastTimeAfterCounter returns a count of finished PublisherSyncStorageMock.HadLoadingErrorLastTime invocations
func (mmHadLoadingErrorLastTime *PublisherSyncStorageMock) HadLoadingErrorLastTimeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHadLoadingErrorLastTime.afterHadLoadingErrorLastTimeCounter)
}

// HadLoadingErrorLastTimeBeforeCounter returns a count of PublisherSyncStorageMock.HadLoadingErrorLastTime invocations
func (mmHadLoadingErrorLastTime *PublisherSyncStorageMock) HadLoadingErrorLastTimeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHadLoadingErrorLastTime.beforeHadLoadingErrorLastTimeCounter)
}

// Calls returns a list of arguments used in each call to PublisherSyncStorageMock.HadLoadingErrorLastTime.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHadLoadingErrorLastTime *mPublisherSyncStorageMockHadLoadingErrorLastTime) Calls() []*PublisherSyncStorageMockHadLoadingErrorLastTimeParams {
	mmHadLoadingErrorLastTime.mutex.RLock()

	argCopy := make([]*PublisherSyncStorageMockHadLoadingErrorLastTimeParams, len(mmHadLoadingErrorLastTime.callArgs))
	copy(argCopy, mmHadLoadingErrorLastTime.callArgs)

	mmHadLoadingErrorLastTime.mutex.RUnlock()

	return argCopy
}

// MinimockHadLoadingErrorLastTimeDone returns true if the count of the HadLoadingErrorLastTime invocations corresponds
// the number of defined expectations
func (m *PublisherSyncStorageMock) MinimockHadLoadingErrorLastTimeDone() bool {
	for _, e := range m.HadLoadingErrorLastTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HadLoadingErrorLastTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHadLoadingErrorLastTimeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHadLoadingErrorLastTime != nil && mm_atomic.LoadUint64(&m.afterHadLoadingErrorLastTimeCounter) < 1 {
		return false
	}
	return true
}

// MinimockHadLoadingErrorLastTimeInspect logs each unmet expectation
func (m *PublisherSyncStorageMock) MinimockHadLoadingErrorLastTimeInspect() {
	for _, e := range m.HadLoadingErrorLastTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.HadLoadingErrorLastTime with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HadLoadingErrorLastTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHadLoadingErrorLastTimeCounter) < 1 {
		if m.HadLoadingErrorLastTimeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherSyncStorageMock.HadLoadingErrorLastTime")
		} else {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.HadLoadingErrorLastTime with params: %#v", *m.HadLoadingErrorLastTimeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHadLoadingErrorLastTime != nil && mm_atomic.LoadUint64(&m.afterHadLoadingErrorLastTimeCounter) < 1 {
		m.t.Error("Expected call to PublisherSyncStorageMock.HadLoadingErrorLastTime")
	}
}

type mPublisherSyncStorageMockSaveResultOfLastSync struct {
	mock               *PublisherSyncStorageMock
	defaultExpectation *PublisherSyncStorageMockSaveResultOfLastSyncExpectation
	expectations       []*PublisherSyncStorageMockSaveResultOfLastSyncExpectation

	callArgs []*PublisherSyncStorageMockSaveResultOfLastSyncParams
	mutex    sync.RWMutex
}

// PublisherSyncStorageMockSaveResultOfLastSyncExpectation specifies expectation struct of the PublisherSyncStorage.SaveResultOfLastSync
type PublisherSyncStorageMockSaveResultOfLastSyncExpectation struct {
	mock    *PublisherSyncStorageMock
	params  *PublisherSyncStorageMockSaveResultOfLastSyncParams
	results *PublisherSyncStorageMockSaveResultOfLastSyncResults
	Counter uint64
}

// PublisherSyncStorageMockSaveResultOfLastSyncParams contains parameters of the PublisherSyncStorage.SaveResultOfLastSync
type PublisherSyncStorageMockSaveResultOfLastSyncParams struct {
	ctx       context.Context
	key       string
	hasErrors bool
}

// PublisherSyncStorageMockSaveResultOfLastSyncResults contains results of the PublisherSyncStorage.SaveResultOfLastSync
type PublisherSyncStorageMockSaveResultOfLastSyncResults struct {
	err error
}

// Expect sets up expected params for PublisherSyncStorage.SaveResultOfLastSync
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Expect(ctx context.Context, key string, hasErrors bool) *mPublisherSyncStorageMockSaveResultOfLastSync {
	if mmSaveResultOfLastSync.mock.funcSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("PublisherSyncStorageMock.SaveResultOfLastSync mock is already set by Set")
	}

	if mmSaveResultOfLastSync.defaultExpectation == nil {
		mmSaveResultOfLastSync.defaultExpectation = &PublisherSyncStorageMockSaveResultOfLastSyncExpectation{}
	}

	mmSaveResultOfLastSync.defaultExpectation.params = &PublisherSyncStorageMockSaveResultOfLastSyncParams{ctx, key, hasErrors}
	for _, e := range mmSaveResultOfLastSync.expectations {
		if minimock.Equal(e.params, mmSaveResultOfLastSync.defaultExpectation.params) {
			mmSaveResultOfLastSync.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveResultOfLastSync.defaultExpectation.params)
		}
	}

	return mmSaveResultOfLastSync
}

// Inspect accepts an inspector function that has same arguments as the PublisherSyncStorage.SaveResultOfLastSync
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Inspect(f func(ctx context.Context, key string, hasErrors bool)) *mPublisherSyncStorageMockSaveResultOfLastSync {
	if mmSaveResultOfLastSync.mock.inspectFuncSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("Inspect function is already set for PublisherSyncStorageMock.SaveResultOfLastSync")
	}

	mmSaveResultOfLastSync.mock.inspectFuncSaveResultOfLastSync = f

	return mmSaveResultOfLastSync
}

// Return sets up results that will be returned by PublisherSyncStorage.SaveResultOfLastSync
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Return(err error) *PublisherSyncStorageMock {
	if mmSaveResultOfLastSync.mock.funcSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("PublisherSyncStorageMock.SaveResultOfLastSync mock is already set by Set")
	}

	if mmSaveResultOfLastSync.defaultExpectation == nil {
		mmSaveResultOfLastSync.defaultExpectation = &PublisherSyncStorageMockSaveResultOfLastSyncExpectation{mock: mmSaveResultOfLastSync.mock}
	}
	mmSaveResultOfLastSync.defaultExpectation.results = &PublisherSyncStorageMockSaveResultOfLastSyncResults{err}
	return mmSaveResultOfLastSync.mock
}

// Set uses given function f to mock the PublisherSyncStorage.SaveResultOfLastSync method
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Set(f func(ctx context.Context, key string, hasErrors bool) (err error)) *PublisherSyncStorageMock {
	if mmSaveResultOfLastSync.defaultExpectation != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("Default expectation is already set for the PublisherSyncStorage.SaveResultOfLastSync method")
	}

	if len(mmSaveResultOfLastSync.expectations) > 0 {
		mmSaveResultOfLastSync.mock.t.Fatalf("Some expectations are already set for the PublisherSyncStorage.SaveResultOfLastSync method")
	}

	mmSaveResultOfLastSync.mock.funcSaveResultOfLastSync = f
	return mmSaveResultOfLastSync.mock
}

// When sets expectation for the PublisherSyncStorage.SaveResultOfLastSync which will trigger the result defined by the following
// Then helper
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) When(ctx context.Context, key string, hasErrors bool) *PublisherSyncStorageMockSaveResultOfLastSyncExpectation {
	if mmSaveResultOfLastSync.mock.funcSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.mock.t.Fatalf("PublisherSyncStorageMock.SaveResultOfLastSync mock is already set by Set")
	}

	expectation := &PublisherSyncStorageMockSaveResultOfLastSyncExpectation{
		mock:   mmSaveResultOfLastSync.mock,
		params: &PublisherSyncStorageMockSaveResultOfLastSyncParams{ctx, key, hasErrors},
	}
	mmSaveResultOfLastSync.expectations = append(mmSaveResultOfLastSync.expectations, expectation)
	return expectation
}

// Then sets up PublisherSyncStorage.SaveResultOfLastSync return parameters for the expectation previously defined by the When method
func (e *PublisherSyncStorageMockSaveResultOfLastSyncExpectation) Then(err error) *PublisherSyncStorageMock {
	e.results = &PublisherSyncStorageMockSaveResultOfLastSyncResults{err}
	return e.mock
}

// SaveResultOfLastSync implements db.PublisherSyncStorage
func (mmSaveResultOfLastSync *PublisherSyncStorageMock) SaveResultOfLastSync(ctx context.Context, key string, hasErrors bool) (err error) {
	mm_atomic.AddUint64(&mmSaveResultOfLastSync.beforeSaveResultOfLastSyncCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveResultOfLastSync.afterSaveResultOfLastSyncCounter, 1)

	if mmSaveResultOfLastSync.inspectFuncSaveResultOfLastSync != nil {
		mmSaveResultOfLastSync.inspectFuncSaveResultOfLastSync(ctx, key, hasErrors)
	}

	mm_params := PublisherSyncStorageMockSaveResultOfLastSyncParams{ctx, key, hasErrors}

	// Record call args
	mmSaveResultOfLastSync.SaveResultOfLastSyncMock.mutex.Lock()
	mmSaveResultOfLastSync.SaveResultOfLastSyncMock.callArgs = append(mmSaveResultOfLastSync.SaveResultOfLastSyncMock.callArgs, &mm_params)
	mmSaveResultOfLastSync.SaveResultOfLastSyncMock.mutex.Unlock()

	for _, e := range mmSaveResultOfLastSync.SaveResultOfLastSyncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveResultOfLastSync.SaveResultOfLastSyncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveResultOfLastSync.SaveResultOfLastSyncMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveResultOfLastSync.SaveResultOfLastSyncMock.defaultExpectation.params
		mm_got := PublisherSyncStorageMockSaveResultOfLastSyncParams{ctx, key, hasErrors}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveResultOfLastSync.t.Errorf("PublisherSyncStorageMock.SaveResultOfLastSync got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveResultOfLastSync.SaveResultOfLastSyncMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveResultOfLastSync.t.Fatal("No results are set for the PublisherSyncStorageMock.SaveResultOfLastSync")
		}
		return (*mm_results).err
	}
	if mmSaveResultOfLastSync.funcSaveResultOfLastSync != nil {
		return mmSaveResultOfLastSync.funcSaveResultOfLastSync(ctx, key, hasErrors)
	}
	mmSaveResultOfLastSync.t.Fatalf("Unexpected call to PublisherSyncStorageMock.SaveResultOfLastSync. %v %v %v", ctx, key, hasErrors)
	return
}

// SaveResultOfLastSyncAfterCounter returns a count of finished PublisherSyncStorageMock.SaveResultOfLastSync invocations
func (mmSaveResultOfLastSync *PublisherSyncStorageMock) SaveResultOfLastSyncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveResultOfLastSync.afterSaveResultOfLastSyncCounter)
}

// SaveResultOfLastSyncBeforeCounter returns a count of PublisherSyncStorageMock.SaveResultOfLastSync invocations
func (mmSaveResultOfLastSync *PublisherSyncStorageMock) SaveResultOfLastSyncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveResultOfLastSync.beforeSaveResultOfLastSyncCounter)
}

// Calls returns a list of arguments used in each call to PublisherSyncStorageMock.SaveResultOfLastSync.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveResultOfLastSync *mPublisherSyncStorageMockSaveResultOfLastSync) Calls() []*PublisherSyncStorageMockSaveResultOfLastSyncParams {
	mmSaveResultOfLastSync.mutex.RLock()

	argCopy := make([]*PublisherSyncStorageMockSaveResultOfLastSyncParams, len(mmSaveResultOfLastSync.callArgs))
	copy(argCopy, mmSaveResultOfLastSync.callArgs)

	mmSaveResultOfLastSync.mutex.RUnlock()

	return argCopy
}

// MinimockSaveResultOfLastSyncDone returns true if the count of the SaveResultOfLastSync invocations corresponds
// the number of defined expectations
func (m *PublisherSyncStorageMock) MinimockSaveResultOfLastSyncDone() bool {
	for _, e := range m.SaveResultOfLastSyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveResultOfLastSyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveResultOfLastSyncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveResultOfLastSync != nil && mm_atomic.LoadUint64(&m.afterSaveResultOfLastSyncCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveResultOfLastSyncInspect logs each unmet expectation
func (m *PublisherSyncStorageMock) MinimockSaveResultOfLastSyncInspect() {
	for _, e := range m.SaveResultOfLastSyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.SaveResultOfLastSync with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveResultOfLastSyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveResultOfLastSyncCounter) < 1 {
		if m.SaveResultOfLastSyncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherSyncStorageMock.SaveResultOfLastSync")
		} else {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.SaveResultOfLastSync with params: %#v", *m.SaveResultOfLastSyncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveResultOfLastSync != nil && mm_atomic.LoadUint64(&m.afterSaveResultOfLastSyncCounter) < 1 {
		m.t.Error("Expected call to PublisherSyncStorageMock.SaveResultOfLastSync")
	}
}

type mPublisherSyncStorageMockUpsertPublisherAndDomains struct {
	mock               *PublisherSyncStorageMock
	defaultExpectation *PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation
	expectations       []*PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation

	callArgs []*PublisherSyncStorageMockUpsertPublisherAndDomainsParams
	mutex    sync.RWMutex
}

// PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation specifies expectation struct of the PublisherSyncStorage.UpsertPublisherAndDomains
type PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation struct {
	mock    *PublisherSyncStorageMock
	params  *PublisherSyncStorageMockUpsertPublisherAndDomainsParams
	results *PublisherSyncStorageMockUpsertPublisherAndDomainsResults
	Counter uint64
}

// PublisherSyncStorageMockUpsertPublisherAndDomainsParams contains parameters of the PublisherSyncStorage.UpsertPublisherAndDomains
type PublisherSyncStorageMockUpsertPublisherAndDomainsParams struct {
	ctx           context.Context
	publisher     *models.Publisher
	domains       []*models.PublisherDomain
	updateColumns boil.Columns
}

// PublisherSyncStorageMockUpsertPublisherAndDomainsResults contains results of the PublisherSyncStorage.UpsertPublisherAndDomains
type PublisherSyncStorageMockUpsertPublisherAndDomainsResults struct {
	err error
}

// Expect sets up expected params for PublisherSyncStorage.UpsertPublisherAndDomains
func (mmUpsertPublisherAndDomains *mPublisherSyncStorageMockUpsertPublisherAndDomains) Expect(ctx context.Context, publisher *models.Publisher, domains []*models.PublisherDomain, updateColumns boil.Columns) *mPublisherSyncStorageMockUpsertPublisherAndDomains {
	if mmUpsertPublisherAndDomains.mock.funcUpsertPublisherAndDomains != nil {
		mmUpsertPublisherAndDomains.mock.t.Fatalf("PublisherSyncStorageMock.UpsertPublisherAndDomains mock is already set by Set")
	}

	if mmUpsertPublisherAndDomains.defaultExpectation == nil {
		mmUpsertPublisherAndDomains.defaultExpectation = &PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation{}
	}

	mmUpsertPublisherAndDomains.defaultExpectation.params = &PublisherSyncStorageMockUpsertPublisherAndDomainsParams{ctx, publisher, domains, updateColumns}
	for _, e := range mmUpsertPublisherAndDomains.expectations {
		if minimock.Equal(e.params, mmUpsertPublisherAndDomains.defaultExpectation.params) {
			mmUpsertPublisherAndDomains.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertPublisherAndDomains.defaultExpectation.params)
		}
	}

	return mmUpsertPublisherAndDomains
}

// Inspect accepts an inspector function that has same arguments as the PublisherSyncStorage.UpsertPublisherAndDomains
func (mmUpsertPublisherAndDomains *mPublisherSyncStorageMockUpsertPublisherAndDomains) Inspect(f func(ctx context.Context, publisher *models.Publisher, domains []*models.PublisherDomain, updateColumns boil.Columns)) *mPublisherSyncStorageMockUpsertPublisherAndDomains {
	if mmUpsertPublisherAndDomains.mock.inspectFuncUpsertPublisherAndDomains != nil {
		mmUpsertPublisherAndDomains.mock.t.Fatalf("Inspect function is already set for PublisherSyncStorageMock.UpsertPublisherAndDomains")
	}

	mmUpsertPublisherAndDomains.mock.inspectFuncUpsertPublisherAndDomains = f

	return mmUpsertPublisherAndDomains
}

// Return sets up results that will be returned by PublisherSyncStorage.UpsertPublisherAndDomains
func (mmUpsertPublisherAndDomains *mPublisherSyncStorageMockUpsertPublisherAndDomains) Return(err error) *PublisherSyncStorageMock {
	if mmUpsertPublisherAndDomains.mock.funcUpsertPublisherAndDomains != nil {
		mmUpsertPublisherAndDomains.mock.t.Fatalf("PublisherSyncStorageMock.UpsertPublisherAndDomains mock is already set by Set")
	}

	if mmUpsertPublisherAndDomains.defaultExpectation == nil {
		mmUpsertPublisherAndDomains.defaultExpectation = &PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation{mock: mmUpsertPublisherAndDomains.mock}
	}
	mmUpsertPublisherAndDomains.defaultExpectation.results = &PublisherSyncStorageMockUpsertPublisherAndDomainsResults{err}
	return mmUpsertPublisherAndDomains.mock
}

// Set uses given function f to mock the PublisherSyncStorage.UpsertPublisherAndDomains method
func (mmUpsertPublisherAndDomains *mPublisherSyncStorageMockUpsertPublisherAndDomains) Set(f func(ctx context.Context, publisher *models.Publisher, domains []*models.PublisherDomain, updateColumns boil.Columns) (err error)) *PublisherSyncStorageMock {
	if mmUpsertPublisherAndDomains.defaultExpectation != nil {
		mmUpsertPublisherAndDomains.mock.t.Fatalf("Default expectation is already set for the PublisherSyncStorage.UpsertPublisherAndDomains method")
	}

	if len(mmUpsertPublisherAndDomains.expectations) > 0 {
		mmUpsertPublisherAndDomains.mock.t.Fatalf("Some expectations are already set for the PublisherSyncStorage.UpsertPublisherAndDomains method")
	}

	mmUpsertPublisherAndDomains.mock.funcUpsertPublisherAndDomains = f
	return mmUpsertPublisherAndDomains.mock
}

// When sets expectation for the PublisherSyncStorage.UpsertPublisherAndDomains which will trigger the result defined by the following
// Then helper
func (mmUpsertPublisherAndDomains *mPublisherSyncStorageMockUpsertPublisherAndDomains) When(ctx context.Context, publisher *models.Publisher, domains []*models.PublisherDomain, updateColumns boil.Columns) *PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation {
	if mmUpsertPublisherAndDomains.mock.funcUpsertPublisherAndDomains != nil {
		mmUpsertPublisherAndDomains.mock.t.Fatalf("PublisherSyncStorageMock.UpsertPublisherAndDomains mock is already set by Set")
	}

	expectation := &PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation{
		mock:   mmUpsertPublisherAndDomains.mock,
		params: &PublisherSyncStorageMockUpsertPublisherAndDomainsParams{ctx, publisher, domains, updateColumns},
	}
	mmUpsertPublisherAndDomains.expectations = append(mmUpsertPublisherAndDomains.expectations, expectation)
	return expectation
}

// Then sets up PublisherSyncStorage.UpsertPublisherAndDomains return parameters for the expectation previously defined by the When method
func (e *PublisherSyncStorageMockUpsertPublisherAndDomainsExpectation) Then(err error) *PublisherSyncStorageMock {
	e.results = &PublisherSyncStorageMockUpsertPublisherAndDomainsResults{err}
	return e.mock
}

// UpsertPublisherAndDomains implements db.PublisherSyncStorage
func (mmUpsertPublisherAndDomains *PublisherSyncStorageMock) UpsertPublisherAndDomains(ctx context.Context, publisher *models.Publisher, domains []*models.PublisherDomain, updateColumns boil.Columns) (err error) {
	mm_atomic.AddUint64(&mmUpsertPublisherAndDomains.beforeUpsertPublisherAndDomainsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertPublisherAndDomains.afterUpsertPublisherAndDomainsCounter, 1)

	if mmUpsertPublisherAndDomains.inspectFuncUpsertPublisherAndDomains != nil {
		mmUpsertPublisherAndDomains.inspectFuncUpsertPublisherAndDomains(ctx, publisher, domains, updateColumns)
	}

	mm_params := PublisherSyncStorageMockUpsertPublisherAndDomainsParams{ctx, publisher, domains, updateColumns}

	// Record call args
	mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.mutex.Lock()
	mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.callArgs = append(mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.callArgs, &mm_params)
	mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.mutex.Unlock()

	for _, e := range mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.defaultExpectation.params
		mm_got := PublisherSyncStorageMockUpsertPublisherAndDomainsParams{ctx, publisher, domains, updateColumns}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertPublisherAndDomains.t.Errorf("PublisherSyncStorageMock.UpsertPublisherAndDomains got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertPublisherAndDomains.UpsertPublisherAndDomainsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertPublisherAndDomains.t.Fatal("No results are set for the PublisherSyncStorageMock.UpsertPublisherAndDomains")
		}
		return (*mm_results).err
	}
	if mmUpsertPublisherAndDomains.funcUpsertPublisherAndDomains != nil {
		return mmUpsertPublisherAndDomains.funcUpsertPublisherAndDomains(ctx, publisher, domains, updateColumns)
	}
	mmUpsertPublisherAndDomains.t.Fatalf("Unexpected call to PublisherSyncStorageMock.UpsertPublisherAndDomains. %v %v %v %v", ctx, publisher, domains, updateColumns)
	return
}

// UpsertPublisherAndDomainsAfterCounter returns a count of finished PublisherSyncStorageMock.UpsertPublisherAndDomains invocations
func (mmUpsertPublisherAndDomains *PublisherSyncStorageMock) UpsertPublisherAndDomainsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertPublisherAndDomains.afterUpsertPublisherAndDomainsCounter)
}

// UpsertPublisherAndDomainsBeforeCounter returns a count of PublisherSyncStorageMock.UpsertPublisherAndDomains invocations
func (mmUpsertPublisherAndDomains *PublisherSyncStorageMock) UpsertPublisherAndDomainsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertPublisherAndDomains.beforeUpsertPublisherAndDomainsCounter)
}

// Calls returns a list of arguments used in each call to PublisherSyncStorageMock.UpsertPublisherAndDomains.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertPublisherAndDomains *mPublisherSyncStorageMockUpsertPublisherAndDomains) Calls() []*PublisherSyncStorageMockUpsertPublisherAndDomainsParams {
	mmUpsertPublisherAndDomains.mutex.RLock()

	argCopy := make([]*PublisherSyncStorageMockUpsertPublisherAndDomainsParams, len(mmUpsertPublisherAndDomains.callArgs))
	copy(argCopy, mmUpsertPublisherAndDomains.callArgs)

	mmUpsertPublisherAndDomains.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertPublisherAndDomainsDone returns true if the count of the UpsertPublisherAndDomains invocations corresponds
// the number of defined expectations
func (m *PublisherSyncStorageMock) MinimockUpsertPublisherAndDomainsDone() bool {
	for _, e := range m.UpsertPublisherAndDomainsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertPublisherAndDomainsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertPublisherAndDomainsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertPublisherAndDomains != nil && mm_atomic.LoadUint64(&m.afterUpsertPublisherAndDomainsCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertPublisherAndDomainsInspect logs each unmet expectation
func (m *PublisherSyncStorageMock) MinimockUpsertPublisherAndDomainsInspect() {
	for _, e := range m.UpsertPublisherAndDomainsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.UpsertPublisherAndDomains with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertPublisherAndDomainsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertPublisherAndDomainsCounter) < 1 {
		if m.UpsertPublisherAndDomainsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PublisherSyncStorageMock.UpsertPublisherAndDomains")
		} else {
			m.t.Errorf("Expected call to PublisherSyncStorageMock.UpsertPublisherAndDomains with params: %#v", *m.UpsertPublisherAndDomainsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertPublisherAndDomains != nil && mm_atomic.LoadUint64(&m.afterUpsertPublisherAndDomainsCounter) < 1 {
		m.t.Error("Expected call to PublisherSyncStorageMock.UpsertPublisherAndDomains")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PublisherSyncStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockHadLoadingErrorLastTimeInspect()

			m.MinimockSaveResultOfLastSyncInspect()

			m.MinimockUpsertPublisherAndDomainsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PublisherSyncStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PublisherSyncStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockHadLoadingErrorLastTimeDone() &&
		m.MinimockSaveResultOfLastSyncDone() &&
		m.MinimockUpsertPublisherAndDomainsDone()
}
