// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// AdsTXT is an object representing the database table.
type AdsTXT struct {
	ID                        int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	DemandPartnerConnectionID null.Int    `boil:"demand_partner_connection_id" json:"demand_partner_connection_id,omitempty" toml:"demand_partner_connection_id" yaml:"demand_partner_connection_id,omitempty"`
	DemandPartnerChildID      null.Int    `boil:"demand_partner_child_id" json:"demand_partner_child_id,omitempty" toml:"demand_partner_child_id" yaml:"demand_partner_child_id,omitempty"`
	SeatOwnerID               null.Int    `boil:"seat_owner_id" json:"seat_owner_id,omitempty" toml:"seat_owner_id" yaml:"seat_owner_id,omitempty"`
	PublisherID               string      `boil:"publisher_id" json:"publisher_id" toml:"publisher_id" yaml:"publisher_id"`
	Domain                    string      `boil:"domain" json:"domain" toml:"domain" yaml:"domain"`
	Status                    string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	DemandStatus              string      `boil:"demand_status" json:"demand_status" toml:"demand_status" yaml:"demand_status"`
	DomainStatus              string      `boil:"domain_status" json:"domain_status" toml:"domain_status" yaml:"domain_status"`
	CreatedAt                 time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                 null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	StatusChangedAt           null.Time   `boil:"status_changed_at" json:"status_changed_at,omitempty" toml:"status_changed_at" yaml:"status_changed_at,omitempty"`
	LastScannedAt             null.Time   `boil:"last_scanned_at" json:"last_scanned_at,omitempty" toml:"last_scanned_at" yaml:"last_scanned_at,omitempty"`
	ErrorMessage              null.String `boil:"error_message" json:"error_message,omitempty" toml:"error_message" yaml:"error_message,omitempty"`
	Retries                   null.Int    `boil:"retries" json:"retries,omitempty" toml:"retries" yaml:"retries,omitempty"`
	ValidURL                  null.String `boil:"valid_url" json:"valid_url,omitempty" toml:"valid_url" yaml:"valid_url,omitempty"`

	R *adsTXTR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L adsTXTL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AdsTXTColumns = struct {
	ID                        string
	DemandPartnerConnectionID string
	DemandPartnerChildID      string
	SeatOwnerID               string
	PublisherID               string
	Domain                    string
	Status                    string
	DemandStatus              string
	DomainStatus              string
	CreatedAt                 string
	UpdatedAt                 string
	StatusChangedAt           string
	LastScannedAt             string
	ErrorMessage              string
	Retries                   string
	ValidURL                  string
}{
	ID:                        "id",
	DemandPartnerConnectionID: "demand_partner_connection_id",
	DemandPartnerChildID:      "demand_partner_child_id",
	SeatOwnerID:               "seat_owner_id",
	PublisherID:               "publisher_id",
	Domain:                    "domain",
	Status:                    "status",
	DemandStatus:              "demand_status",
	DomainStatus:              "domain_status",
	CreatedAt:                 "created_at",
	UpdatedAt:                 "updated_at",
	StatusChangedAt:           "status_changed_at",
	LastScannedAt:             "last_scanned_at",
	ErrorMessage:              "error_message",
	Retries:                   "retries",
	ValidURL:                  "valid_url",
}

var AdsTXTTableColumns = struct {
	ID                        string
	DemandPartnerConnectionID string
	DemandPartnerChildID      string
	SeatOwnerID               string
	PublisherID               string
	Domain                    string
	Status                    string
	DemandStatus              string
	DomainStatus              string
	CreatedAt                 string
	UpdatedAt                 string
	StatusChangedAt           string
	LastScannedAt             string
	ErrorMessage              string
	Retries                   string
	ValidURL                  string
}{
	ID:                        "ads_txt.id",
	DemandPartnerConnectionID: "ads_txt.demand_partner_connection_id",
	DemandPartnerChildID:      "ads_txt.demand_partner_child_id",
	SeatOwnerID:               "ads_txt.seat_owner_id",
	PublisherID:               "ads_txt.publisher_id",
	Domain:                    "ads_txt.domain",
	Status:                    "ads_txt.status",
	DemandStatus:              "ads_txt.demand_status",
	DomainStatus:              "ads_txt.domain_status",
	CreatedAt:                 "ads_txt.created_at",
	UpdatedAt:                 "ads_txt.updated_at",
	StatusChangedAt:           "ads_txt.status_changed_at",
	LastScannedAt:             "ads_txt.last_scanned_at",
	ErrorMessage:              "ads_txt.error_message",
	Retries:                   "ads_txt.retries",
	ValidURL:                  "ads_txt.valid_url",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) LIKE(x string) qm.QueryMod   { return qm.Where(w.field+" LIKE ?", x) }
func (w whereHelperstring) NLIKE(x string) qm.QueryMod  { return qm.Where(w.field+" NOT LIKE ?", x) }
func (w whereHelperstring) ILIKE(x string) qm.QueryMod  { return qm.Where(w.field+" ILIKE ?", x) }
func (w whereHelperstring) NILIKE(x string) qm.QueryMod { return qm.Where(w.field+" NOT ILIKE ?", x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) LIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" LIKE ?", x)
}
func (w whereHelpernull_String) NLIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT LIKE ?", x)
}
func (w whereHelpernull_String) ILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" ILIKE ?", x)
}
func (w whereHelpernull_String) NILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT ILIKE ?", x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var AdsTXTWhere = struct {
	ID                        whereHelperint
	DemandPartnerConnectionID whereHelpernull_Int
	DemandPartnerChildID      whereHelpernull_Int
	SeatOwnerID               whereHelpernull_Int
	PublisherID               whereHelperstring
	Domain                    whereHelperstring
	Status                    whereHelperstring
	DemandStatus              whereHelperstring
	DomainStatus              whereHelperstring
	CreatedAt                 whereHelpertime_Time
	UpdatedAt                 whereHelpernull_Time
	StatusChangedAt           whereHelpernull_Time
	LastScannedAt             whereHelpernull_Time
	ErrorMessage              whereHelpernull_String
	Retries                   whereHelpernull_Int
	ValidURL                  whereHelpernull_String
}{
	ID:                        whereHelperint{field: "\"ads_txt\".\"id\""},
	DemandPartnerConnectionID: whereHelpernull_Int{field: "\"ads_txt\".\"demand_partner_connection_id\""},
	DemandPartnerChildID:      whereHelpernull_Int{field: "\"ads_txt\".\"demand_partner_child_id\""},
	SeatOwnerID:               whereHelpernull_Int{field: "\"ads_txt\".\"seat_owner_id\""},
	PublisherID:               whereHelperstring{field: "\"ads_txt\".\"publisher_id\""},
	Domain:                    whereHelperstring{field: "\"ads_txt\".\"domain\""},
	Status:                    whereHelperstring{field: "\"ads_txt\".\"status\""},
	DemandStatus:              whereHelperstring{field: "\"ads_txt\".\"demand_status\""},
	DomainStatus:              whereHelperstring{field: "\"ads_txt\".\"domain_status\""},
	CreatedAt:                 whereHelpertime_Time{field: "\"ads_txt\".\"created_at\""},
	UpdatedAt:                 whereHelpernull_Time{field: "\"ads_txt\".\"updated_at\""},
	StatusChangedAt:           whereHelpernull_Time{field: "\"ads_txt\".\"status_changed_at\""},
	LastScannedAt:             whereHelpernull_Time{field: "\"ads_txt\".\"last_scanned_at\""},
	ErrorMessage:              whereHelpernull_String{field: "\"ads_txt\".\"error_message\""},
	Retries:                   whereHelpernull_Int{field: "\"ads_txt\".\"retries\""},
	ValidURL:                  whereHelpernull_String{field: "\"ads_txt\".\"valid_url\""},
}

// AdsTXTRels is where relationship names are stored.
var AdsTXTRels = struct {
	DemandPartnerChild      string
	DemandPartnerConnection string
	Publisher               string
	SeatOwner               string
}{
	DemandPartnerChild:      "DemandPartnerChild",
	DemandPartnerConnection: "DemandPartnerConnection",
	Publisher:               "Publisher",
	SeatOwner:               "SeatOwner",
}

// adsTXTR is where relationships are stored.
type adsTXTR struct {
	DemandPartnerChild      *DemandPartnerChild      `boil:"DemandPartnerChild" json:"DemandPartnerChild" toml:"DemandPartnerChild" yaml:"DemandPartnerChild"`
	DemandPartnerConnection *DemandPartnerConnection `boil:"DemandPartnerConnection" json:"DemandPartnerConnection" toml:"DemandPartnerConnection" yaml:"DemandPartnerConnection"`
	Publisher               *Publisher               `boil:"Publisher" json:"Publisher" toml:"Publisher" yaml:"Publisher"`
	SeatOwner               *SeatOwner               `boil:"SeatOwner" json:"SeatOwner" toml:"SeatOwner" yaml:"SeatOwner"`
}

// NewStruct creates a new relationship struct
func (*adsTXTR) NewStruct() *adsTXTR {
	return &adsTXTR{}
}

func (r *adsTXTR) GetDemandPartnerChild() *DemandPartnerChild {
	if r == nil {
		return nil
	}
	return r.DemandPartnerChild
}

func (r *adsTXTR) GetDemandPartnerConnection() *DemandPartnerConnection {
	if r == nil {
		return nil
	}
	return r.DemandPartnerConnection
}

func (r *adsTXTR) GetPublisher() *Publisher {
	if r == nil {
		return nil
	}
	return r.Publisher
}

func (r *adsTXTR) GetSeatOwner() *SeatOwner {
	if r == nil {
		return nil
	}
	return r.SeatOwner
}

// adsTXTL is where Load methods for each relationship are stored.
type adsTXTL struct{}

var (
	adsTXTAllColumns            = []string{"id", "demand_partner_connection_id", "demand_partner_child_id", "seat_owner_id", "publisher_id", "domain", "status", "demand_status", "domain_status", "created_at", "updated_at", "status_changed_at", "last_scanned_at", "error_message", "retries", "valid_url"}
	adsTXTColumnsWithoutDefault = []string{"publisher_id", "domain", "created_at"}
	adsTXTColumnsWithDefault    = []string{"id", "demand_partner_connection_id", "demand_partner_child_id", "seat_owner_id", "status", "demand_status", "domain_status", "updated_at", "status_changed_at", "last_scanned_at", "error_message", "retries", "valid_url"}
	adsTXTPrimaryKeyColumns     = []string{"id"}
	adsTXTGeneratedColumns      = []string{}
)

type (
	// AdsTXTSlice is an alias for a slice of pointers to AdsTXT.
	// This should almost always be used instead of []AdsTXT.
	AdsTXTSlice []*AdsTXT
	// AdsTXTHook is the signature for custom AdsTXT hook methods
	AdsTXTHook func(context.Context, boil.ContextExecutor, *AdsTXT) error

	adsTXTQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	adsTXTType                 = reflect.TypeOf(&AdsTXT{})
	adsTXTMapping              = queries.MakeStructMapping(adsTXTType)
	adsTXTPrimaryKeyMapping, _ = queries.BindMapping(adsTXTType, adsTXTMapping, adsTXTPrimaryKeyColumns)
	adsTXTInsertCacheMut       sync.RWMutex
	adsTXTInsertCache          = make(map[string]insertCache)
	adsTXTUpdateCacheMut       sync.RWMutex
	adsTXTUpdateCache          = make(map[string]updateCache)
	adsTXTUpsertCacheMut       sync.RWMutex
	adsTXTUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var adsTXTAfterSelectMu sync.Mutex
var adsTXTAfterSelectHooks []AdsTXTHook

var adsTXTBeforeInsertMu sync.Mutex
var adsTXTBeforeInsertHooks []AdsTXTHook
var adsTXTAfterInsertMu sync.Mutex
var adsTXTAfterInsertHooks []AdsTXTHook

var adsTXTBeforeUpdateMu sync.Mutex
var adsTXTBeforeUpdateHooks []AdsTXTHook
var adsTXTAfterUpdateMu sync.Mutex
var adsTXTAfterUpdateHooks []AdsTXTHook

var adsTXTBeforeDeleteMu sync.Mutex
var adsTXTBeforeDeleteHooks []AdsTXTHook
var adsTXTAfterDeleteMu sync.Mutex
var adsTXTAfterDeleteHooks []AdsTXTHook

var adsTXTBeforeUpsertMu sync.Mutex
var adsTXTBeforeUpsertHooks []AdsTXTHook
var adsTXTAfterUpsertMu sync.Mutex
var adsTXTAfterUpsertHooks []AdsTXTHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *AdsTXT) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *AdsTXT) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *AdsTXT) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *AdsTXT) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *AdsTXT) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *AdsTXT) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *AdsTXT) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *AdsTXT) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *AdsTXT) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range adsTXTAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAdsTXTHook registers your hook function for all future operations.
func AddAdsTXTHook(hookPoint boil.HookPoint, adsTXTHook AdsTXTHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		adsTXTAfterSelectMu.Lock()
		adsTXTAfterSelectHooks = append(adsTXTAfterSelectHooks, adsTXTHook)
		adsTXTAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		adsTXTBeforeInsertMu.Lock()
		adsTXTBeforeInsertHooks = append(adsTXTBeforeInsertHooks, adsTXTHook)
		adsTXTBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		adsTXTAfterInsertMu.Lock()
		adsTXTAfterInsertHooks = append(adsTXTAfterInsertHooks, adsTXTHook)
		adsTXTAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		adsTXTBeforeUpdateMu.Lock()
		adsTXTBeforeUpdateHooks = append(adsTXTBeforeUpdateHooks, adsTXTHook)
		adsTXTBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		adsTXTAfterUpdateMu.Lock()
		adsTXTAfterUpdateHooks = append(adsTXTAfterUpdateHooks, adsTXTHook)
		adsTXTAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		adsTXTBeforeDeleteMu.Lock()
		adsTXTBeforeDeleteHooks = append(adsTXTBeforeDeleteHooks, adsTXTHook)
		adsTXTBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		adsTXTAfterDeleteMu.Lock()
		adsTXTAfterDeleteHooks = append(adsTXTAfterDeleteHooks, adsTXTHook)
		adsTXTAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		adsTXTBeforeUpsertMu.Lock()
		adsTXTBeforeUpsertHooks = append(adsTXTBeforeUpsertHooks, adsTXTHook)
		adsTXTBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		adsTXTAfterUpsertMu.Lock()
		adsTXTAfterUpsertHooks = append(adsTXTAfterUpsertHooks, adsTXTHook)
		adsTXTAfterUpsertMu.Unlock()
	}
}

// One returns a single adsTXT record from the query.
func (q adsTXTQuery) One(ctx context.Context, exec boil.ContextExecutor) (*AdsTXT, error) {
	o := &AdsTXT{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for ads_txt")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all AdsTXT records from the query.
func (q adsTXTQuery) All(ctx context.Context, exec boil.ContextExecutor) (AdsTXTSlice, error) {
	var o []*AdsTXT

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to AdsTXT slice")
	}

	if len(adsTXTAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all AdsTXT records in the query.
func (q adsTXTQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count ads_txt rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q adsTXTQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if ads_txt exists")
	}

	return count > 0, nil
}

// DemandPartnerChild pointed to by the foreign key.
func (o *AdsTXT) DemandPartnerChild(mods ...qm.QueryMod) demandPartnerChildQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DemandPartnerChildID),
	}

	queryMods = append(queryMods, mods...)

	return DemandPartnerChildren(queryMods...)
}

// DemandPartnerConnection pointed to by the foreign key.
func (o *AdsTXT) DemandPartnerConnection(mods ...qm.QueryMod) demandPartnerConnectionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DemandPartnerConnectionID),
	}

	queryMods = append(queryMods, mods...)

	return DemandPartnerConnections(queryMods...)
}

// Publisher pointed to by the foreign key.
func (o *AdsTXT) Publisher(mods ...qm.QueryMod) publisherQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"publisher_id\" = ?", o.PublisherID),
	}

	queryMods = append(queryMods, mods...)

	return Publishers(queryMods...)
}

// SeatOwner pointed to by the foreign key.
func (o *AdsTXT) SeatOwner(mods ...qm.QueryMod) seatOwnerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SeatOwnerID),
	}

	queryMods = append(queryMods, mods...)

	return SeatOwners(queryMods...)
}

// LoadDemandPartnerChild allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (adsTXTL) LoadDemandPartnerChild(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAdsTXT interface{}, mods queries.Applicator) error {
	var slice []*AdsTXT
	var object *AdsTXT

	if singular {
		var ok bool
		object, ok = maybeAdsTXT.(*AdsTXT)
		if !ok {
			object = new(AdsTXT)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAdsTXT)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAdsTXT))
			}
		}
	} else {
		s, ok := maybeAdsTXT.(*[]*AdsTXT)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAdsTXT)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAdsTXT))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &adsTXTR{}
		}
		if !queries.IsNil(object.DemandPartnerChildID) {
			args[object.DemandPartnerChildID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &adsTXTR{}
			}

			if !queries.IsNil(obj.DemandPartnerChildID) {
				args[obj.DemandPartnerChildID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`demand_partner_child`),
		qm.WhereIn(`demand_partner_child.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DemandPartnerChild")
	}

	var resultSlice []*DemandPartnerChild
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DemandPartnerChild")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for demand_partner_child")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for demand_partner_child")
	}

	if len(demandPartnerChildAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DemandPartnerChild = foreign
		if foreign.R == nil {
			foreign.R = &demandPartnerChildR{}
		}
		foreign.R.AdsTXTS = append(foreign.R.AdsTXTS, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DemandPartnerChildID, foreign.ID) {
				local.R.DemandPartnerChild = foreign
				if foreign.R == nil {
					foreign.R = &demandPartnerChildR{}
				}
				foreign.R.AdsTXTS = append(foreign.R.AdsTXTS, local)
				break
			}
		}
	}

	return nil
}

// LoadDemandPartnerConnection allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (adsTXTL) LoadDemandPartnerConnection(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAdsTXT interface{}, mods queries.Applicator) error {
	var slice []*AdsTXT
	var object *AdsTXT

	if singular {
		var ok bool
		object, ok = maybeAdsTXT.(*AdsTXT)
		if !ok {
			object = new(AdsTXT)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAdsTXT)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAdsTXT))
			}
		}
	} else {
		s, ok := maybeAdsTXT.(*[]*AdsTXT)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAdsTXT)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAdsTXT))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &adsTXTR{}
		}
		if !queries.IsNil(object.DemandPartnerConnectionID) {
			args[object.DemandPartnerConnectionID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &adsTXTR{}
			}

			if !queries.IsNil(obj.DemandPartnerConnectionID) {
				args[obj.DemandPartnerConnectionID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`demand_partner_connection`),
		qm.WhereIn(`demand_partner_connection.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DemandPartnerConnection")
	}

	var resultSlice []*DemandPartnerConnection
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DemandPartnerConnection")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for demand_partner_connection")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for demand_partner_connection")
	}

	if len(demandPartnerConnectionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DemandPartnerConnection = foreign
		if foreign.R == nil {
			foreign.R = &demandPartnerConnectionR{}
		}
		foreign.R.AdsTXTS = append(foreign.R.AdsTXTS, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DemandPartnerConnectionID, foreign.ID) {
				local.R.DemandPartnerConnection = foreign
				if foreign.R == nil {
					foreign.R = &demandPartnerConnectionR{}
				}
				foreign.R.AdsTXTS = append(foreign.R.AdsTXTS, local)
				break
			}
		}
	}

	return nil
}

// LoadPublisher allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (adsTXTL) LoadPublisher(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAdsTXT interface{}, mods queries.Applicator) error {
	var slice []*AdsTXT
	var object *AdsTXT

	if singular {
		var ok bool
		object, ok = maybeAdsTXT.(*AdsTXT)
		if !ok {
			object = new(AdsTXT)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAdsTXT)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAdsTXT))
			}
		}
	} else {
		s, ok := maybeAdsTXT.(*[]*AdsTXT)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAdsTXT)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAdsTXT))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &adsTXTR{}
		}
		args[object.PublisherID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &adsTXTR{}
			}

			args[obj.PublisherID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`publisher`),
		qm.WhereIn(`publisher.publisher_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Publisher")
	}

	var resultSlice []*Publisher
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Publisher")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for publisher")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for publisher")
	}

	if len(publisherAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Publisher = foreign
		if foreign.R == nil {
			foreign.R = &publisherR{}
		}
		foreign.R.AdsTXTS = append(foreign.R.AdsTXTS, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PublisherID == foreign.PublisherID {
				local.R.Publisher = foreign
				if foreign.R == nil {
					foreign.R = &publisherR{}
				}
				foreign.R.AdsTXTS = append(foreign.R.AdsTXTS, local)
				break
			}
		}
	}

	return nil
}

// LoadSeatOwner allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (adsTXTL) LoadSeatOwner(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAdsTXT interface{}, mods queries.Applicator) error {
	var slice []*AdsTXT
	var object *AdsTXT

	if singular {
		var ok bool
		object, ok = maybeAdsTXT.(*AdsTXT)
		if !ok {
			object = new(AdsTXT)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAdsTXT)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAdsTXT))
			}
		}
	} else {
		s, ok := maybeAdsTXT.(*[]*AdsTXT)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAdsTXT)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAdsTXT))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &adsTXTR{}
		}
		if !queries.IsNil(object.SeatOwnerID) {
			args[object.SeatOwnerID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &adsTXTR{}
			}

			if !queries.IsNil(obj.SeatOwnerID) {
				args[obj.SeatOwnerID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`seat_owner`),
		qm.WhereIn(`seat_owner.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SeatOwner")
	}

	var resultSlice []*SeatOwner
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SeatOwner")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for seat_owner")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for seat_owner")
	}

	if len(seatOwnerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SeatOwner = foreign
		if foreign.R == nil {
			foreign.R = &seatOwnerR{}
		}
		foreign.R.AdsTXTS = append(foreign.R.AdsTXTS, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SeatOwnerID, foreign.ID) {
				local.R.SeatOwner = foreign
				if foreign.R == nil {
					foreign.R = &seatOwnerR{}
				}
				foreign.R.AdsTXTS = append(foreign.R.AdsTXTS, local)
				break
			}
		}
	}

	return nil
}

// SetDemandPartnerChild of the adsTXT to the related item.
// Sets o.R.DemandPartnerChild to related.
// Adds o to related.R.AdsTXTS.
func (o *AdsTXT) SetDemandPartnerChild(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DemandPartnerChild) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"ads_txt\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"demand_partner_child_id"}),
		strmangle.WhereClause("\"", "\"", 2, adsTXTPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DemandPartnerChildID, related.ID)
	if o.R == nil {
		o.R = &adsTXTR{
			DemandPartnerChild: related,
		}
	} else {
		o.R.DemandPartnerChild = related
	}

	if related.R == nil {
		related.R = &demandPartnerChildR{
			AdsTXTS: AdsTXTSlice{o},
		}
	} else {
		related.R.AdsTXTS = append(related.R.AdsTXTS, o)
	}

	return nil
}

// RemoveDemandPartnerChild relationship.
// Sets o.R.DemandPartnerChild to nil.
// Removes o from all passed in related items' relationships struct.
func (o *AdsTXT) RemoveDemandPartnerChild(ctx context.Context, exec boil.ContextExecutor, related *DemandPartnerChild) error {
	var err error

	queries.SetScanner(&o.DemandPartnerChildID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("demand_partner_child_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DemandPartnerChild = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AdsTXTS {
		if queries.Equal(o.DemandPartnerChildID, ri.DemandPartnerChildID) {
			continue
		}

		ln := len(related.R.AdsTXTS)
		if ln > 1 && i < ln-1 {
			related.R.AdsTXTS[i] = related.R.AdsTXTS[ln-1]
		}
		related.R.AdsTXTS = related.R.AdsTXTS[:ln-1]
		break
	}
	return nil
}

// SetDemandPartnerConnection of the adsTXT to the related item.
// Sets o.R.DemandPartnerConnection to related.
// Adds o to related.R.AdsTXTS.
func (o *AdsTXT) SetDemandPartnerConnection(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DemandPartnerConnection) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"ads_txt\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"demand_partner_connection_id"}),
		strmangle.WhereClause("\"", "\"", 2, adsTXTPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DemandPartnerConnectionID, related.ID)
	if o.R == nil {
		o.R = &adsTXTR{
			DemandPartnerConnection: related,
		}
	} else {
		o.R.DemandPartnerConnection = related
	}

	if related.R == nil {
		related.R = &demandPartnerConnectionR{
			AdsTXTS: AdsTXTSlice{o},
		}
	} else {
		related.R.AdsTXTS = append(related.R.AdsTXTS, o)
	}

	return nil
}

// RemoveDemandPartnerConnection relationship.
// Sets o.R.DemandPartnerConnection to nil.
// Removes o from all passed in related items' relationships struct.
func (o *AdsTXT) RemoveDemandPartnerConnection(ctx context.Context, exec boil.ContextExecutor, related *DemandPartnerConnection) error {
	var err error

	queries.SetScanner(&o.DemandPartnerConnectionID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("demand_partner_connection_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DemandPartnerConnection = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AdsTXTS {
		if queries.Equal(o.DemandPartnerConnectionID, ri.DemandPartnerConnectionID) {
			continue
		}

		ln := len(related.R.AdsTXTS)
		if ln > 1 && i < ln-1 {
			related.R.AdsTXTS[i] = related.R.AdsTXTS[ln-1]
		}
		related.R.AdsTXTS = related.R.AdsTXTS[:ln-1]
		break
	}
	return nil
}

// SetPublisher of the adsTXT to the related item.
// Sets o.R.Publisher to related.
// Adds o to related.R.AdsTXTS.
func (o *AdsTXT) SetPublisher(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Publisher) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"ads_txt\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"publisher_id"}),
		strmangle.WhereClause("\"", "\"", 2, adsTXTPrimaryKeyColumns),
	)
	values := []interface{}{related.PublisherID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PublisherID = related.PublisherID
	if o.R == nil {
		o.R = &adsTXTR{
			Publisher: related,
		}
	} else {
		o.R.Publisher = related
	}

	if related.R == nil {
		related.R = &publisherR{
			AdsTXTS: AdsTXTSlice{o},
		}
	} else {
		related.R.AdsTXTS = append(related.R.AdsTXTS, o)
	}

	return nil
}

// SetSeatOwner of the adsTXT to the related item.
// Sets o.R.SeatOwner to related.
// Adds o to related.R.AdsTXTS.
func (o *AdsTXT) SetSeatOwner(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SeatOwner) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"ads_txt\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"seat_owner_id"}),
		strmangle.WhereClause("\"", "\"", 2, adsTXTPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SeatOwnerID, related.ID)
	if o.R == nil {
		o.R = &adsTXTR{
			SeatOwner: related,
		}
	} else {
		o.R.SeatOwner = related
	}

	if related.R == nil {
		related.R = &seatOwnerR{
			AdsTXTS: AdsTXTSlice{o},
		}
	} else {
		related.R.AdsTXTS = append(related.R.AdsTXTS, o)
	}

	return nil
}

// RemoveSeatOwner relationship.
// Sets o.R.SeatOwner to nil.
// Removes o from all passed in related items' relationships struct.
func (o *AdsTXT) RemoveSeatOwner(ctx context.Context, exec boil.ContextExecutor, related *SeatOwner) error {
	var err error

	queries.SetScanner(&o.SeatOwnerID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("seat_owner_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.SeatOwner = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AdsTXTS {
		if queries.Equal(o.SeatOwnerID, ri.SeatOwnerID) {
			continue
		}

		ln := len(related.R.AdsTXTS)
		if ln > 1 && i < ln-1 {
			related.R.AdsTXTS[i] = related.R.AdsTXTS[ln-1]
		}
		related.R.AdsTXTS = related.R.AdsTXTS[:ln-1]
		break
	}
	return nil
}

// AdsTXTS retrieves all the records using an executor.
func AdsTXTS(mods ...qm.QueryMod) adsTXTQuery {
	mods = append(mods, qm.From("\"ads_txt\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"ads_txt\".*"})
	}

	return adsTXTQuery{q}
}

// FindAdsTXT retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAdsTXT(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*AdsTXT, error) {
	adsTXTObj := &AdsTXT{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"ads_txt\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, adsTXTObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from ads_txt")
	}

	if err = adsTXTObj.doAfterSelectHooks(ctx, exec); err != nil {
		return adsTXTObj, err
	}

	return adsTXTObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *AdsTXT) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no ads_txt provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(adsTXTColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	adsTXTInsertCacheMut.RLock()
	cache, cached := adsTXTInsertCache[key]
	adsTXTInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			adsTXTAllColumns,
			adsTXTColumnsWithDefault,
			adsTXTColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(adsTXTType, adsTXTMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(adsTXTType, adsTXTMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"ads_txt\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"ads_txt\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into ads_txt")
	}

	if !cached {
		adsTXTInsertCacheMut.Lock()
		adsTXTInsertCache[key] = cache
		adsTXTInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the AdsTXT.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *AdsTXT) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	adsTXTUpdateCacheMut.RLock()
	cache, cached := adsTXTUpdateCache[key]
	adsTXTUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			adsTXTAllColumns,
			adsTXTPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update ads_txt, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"ads_txt\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, adsTXTPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(adsTXTType, adsTXTMapping, append(wl, adsTXTPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update ads_txt row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for ads_txt")
	}

	if !cached {
		adsTXTUpdateCacheMut.Lock()
		adsTXTUpdateCache[key] = cache
		adsTXTUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q adsTXTQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for ads_txt")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for ads_txt")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AdsTXTSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), adsTXTPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"ads_txt\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, adsTXTPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in adsTXT slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all adsTXT")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *AdsTXT) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no ads_txt provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(adsTXTColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	adsTXTUpsertCacheMut.RLock()
	cache, cached := adsTXTUpsertCache[key]
	adsTXTUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			adsTXTAllColumns,
			adsTXTColumnsWithDefault,
			adsTXTColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			adsTXTAllColumns,
			adsTXTPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert ads_txt, could not build update column list")
		}

		ret := strmangle.SetComplement(adsTXTAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(adsTXTPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert ads_txt, could not build conflict column list")
			}

			conflict = make([]string, len(adsTXTPrimaryKeyColumns))
			copy(conflict, adsTXTPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"ads_txt\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(adsTXTType, adsTXTMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(adsTXTType, adsTXTMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert ads_txt")
	}

	if !cached {
		adsTXTUpsertCacheMut.Lock()
		adsTXTUpsertCache[key] = cache
		adsTXTUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single AdsTXT record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *AdsTXT) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no AdsTXT provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), adsTXTPrimaryKeyMapping)
	sql := "DELETE FROM \"ads_txt\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from ads_txt")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for ads_txt")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q adsTXTQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no adsTXTQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from ads_txt")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for ads_txt")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AdsTXTSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(adsTXTBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), adsTXTPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"ads_txt\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, adsTXTPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from adsTXT slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for ads_txt")
	}

	if len(adsTXTAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *AdsTXT) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAdsTXT(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AdsTXTSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AdsTXTSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), adsTXTPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"ads_txt\".* FROM \"ads_txt\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, adsTXTPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AdsTXTSlice")
	}

	*o = slice

	return nil
}

// AdsTXTExists checks if the AdsTXT row exists.
func AdsTXTExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"ads_txt\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if ads_txt exists")
	}

	return exists, nil
}

// Exists checks if the AdsTXT row exists.
func (o *AdsTXT) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return AdsTXTExists(ctx, exec, o.ID)
}
