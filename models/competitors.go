// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Competitor is an object representing the database table.
type Competitor struct {
	CompetitorName string      `boil:"competitor_name" json:"competitor_name" toml:"competitor_name" yaml:"competitor_name"`
	URL            null.String `boil:"url" json:"url,omitempty" toml:"url" yaml:"url,omitempty"`

	R *competitorR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L competitorL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CompetitorColumns = struct {
	CompetitorName string
	URL            string
}{
	CompetitorName: "competitor_name",
	URL:            "url",
}

var CompetitorTableColumns = struct {
	CompetitorName string
	URL            string
}{
	CompetitorName: "competitors.competitor_name",
	URL:            "competitors.url",
}

// Generated where

var CompetitorWhere = struct {
	CompetitorName whereHelperstring
	URL            whereHelpernull_String
}{
	CompetitorName: whereHelperstring{field: "\"competitors\".\"competitor_name\""},
	URL:            whereHelpernull_String{field: "\"competitors\".\"url\""},
}

// CompetitorRels is where relationship names are stored.
var CompetitorRels = struct {
	CompetitorNameSellersJSONHistories string
	URLSellersJSONHistories            string
}{
	CompetitorNameSellersJSONHistories: "CompetitorNameSellersJSONHistories",
	URLSellersJSONHistories:            "URLSellersJSONHistories",
}

// competitorR is where relationships are stored.
type competitorR struct {
	CompetitorNameSellersJSONHistories SellersJSONHistorySlice `boil:"CompetitorNameSellersJSONHistories" json:"CompetitorNameSellersJSONHistories" toml:"CompetitorNameSellersJSONHistories" yaml:"CompetitorNameSellersJSONHistories"`
	URLSellersJSONHistories            SellersJSONHistorySlice `boil:"URLSellersJSONHistories" json:"URLSellersJSONHistories" toml:"URLSellersJSONHistories" yaml:"URLSellersJSONHistories"`
}

// NewStruct creates a new relationship struct
func (*competitorR) NewStruct() *competitorR {
	return &competitorR{}
}

func (r *competitorR) GetCompetitorNameSellersJSONHistories() SellersJSONHistorySlice {
	if r == nil {
		return nil
	}
	return r.CompetitorNameSellersJSONHistories
}

func (r *competitorR) GetURLSellersJSONHistories() SellersJSONHistorySlice {
	if r == nil {
		return nil
	}
	return r.URLSellersJSONHistories
}

// competitorL is where Load methods for each relationship are stored.
type competitorL struct{}

var (
	competitorAllColumns            = []string{"competitor_name", "url"}
	competitorColumnsWithoutDefault = []string{"competitor_name"}
	competitorColumnsWithDefault    = []string{"url"}
	competitorPrimaryKeyColumns     = []string{"competitor_name"}
	competitorGeneratedColumns      = []string{}
)

type (
	// CompetitorSlice is an alias for a slice of pointers to Competitor.
	// This should almost always be used instead of []Competitor.
	CompetitorSlice []*Competitor
	// CompetitorHook is the signature for custom Competitor hook methods
	CompetitorHook func(context.Context, boil.ContextExecutor, *Competitor) error

	competitorQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	competitorType                 = reflect.TypeOf(&Competitor{})
	competitorMapping              = queries.MakeStructMapping(competitorType)
	competitorPrimaryKeyMapping, _ = queries.BindMapping(competitorType, competitorMapping, competitorPrimaryKeyColumns)
	competitorInsertCacheMut       sync.RWMutex
	competitorInsertCache          = make(map[string]insertCache)
	competitorUpdateCacheMut       sync.RWMutex
	competitorUpdateCache          = make(map[string]updateCache)
	competitorUpsertCacheMut       sync.RWMutex
	competitorUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var competitorAfterSelectMu sync.Mutex
var competitorAfterSelectHooks []CompetitorHook

var competitorBeforeInsertMu sync.Mutex
var competitorBeforeInsertHooks []CompetitorHook
var competitorAfterInsertMu sync.Mutex
var competitorAfterInsertHooks []CompetitorHook

var competitorBeforeUpdateMu sync.Mutex
var competitorBeforeUpdateHooks []CompetitorHook
var competitorAfterUpdateMu sync.Mutex
var competitorAfterUpdateHooks []CompetitorHook

var competitorBeforeDeleteMu sync.Mutex
var competitorBeforeDeleteHooks []CompetitorHook
var competitorAfterDeleteMu sync.Mutex
var competitorAfterDeleteHooks []CompetitorHook

var competitorBeforeUpsertMu sync.Mutex
var competitorBeforeUpsertHooks []CompetitorHook
var competitorAfterUpsertMu sync.Mutex
var competitorAfterUpsertHooks []CompetitorHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Competitor) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Competitor) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Competitor) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Competitor) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Competitor) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Competitor) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Competitor) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Competitor) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Competitor) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range competitorAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCompetitorHook registers your hook function for all future operations.
func AddCompetitorHook(hookPoint boil.HookPoint, competitorHook CompetitorHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		competitorAfterSelectMu.Lock()
		competitorAfterSelectHooks = append(competitorAfterSelectHooks, competitorHook)
		competitorAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		competitorBeforeInsertMu.Lock()
		competitorBeforeInsertHooks = append(competitorBeforeInsertHooks, competitorHook)
		competitorBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		competitorAfterInsertMu.Lock()
		competitorAfterInsertHooks = append(competitorAfterInsertHooks, competitorHook)
		competitorAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		competitorBeforeUpdateMu.Lock()
		competitorBeforeUpdateHooks = append(competitorBeforeUpdateHooks, competitorHook)
		competitorBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		competitorAfterUpdateMu.Lock()
		competitorAfterUpdateHooks = append(competitorAfterUpdateHooks, competitorHook)
		competitorAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		competitorBeforeDeleteMu.Lock()
		competitorBeforeDeleteHooks = append(competitorBeforeDeleteHooks, competitorHook)
		competitorBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		competitorAfterDeleteMu.Lock()
		competitorAfterDeleteHooks = append(competitorAfterDeleteHooks, competitorHook)
		competitorAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		competitorBeforeUpsertMu.Lock()
		competitorBeforeUpsertHooks = append(competitorBeforeUpsertHooks, competitorHook)
		competitorBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		competitorAfterUpsertMu.Lock()
		competitorAfterUpsertHooks = append(competitorAfterUpsertHooks, competitorHook)
		competitorAfterUpsertMu.Unlock()
	}
}

// One returns a single competitor record from the query.
func (q competitorQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Competitor, error) {
	o := &Competitor{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for competitors")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Competitor records from the query.
func (q competitorQuery) All(ctx context.Context, exec boil.ContextExecutor) (CompetitorSlice, error) {
	var o []*Competitor

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Competitor slice")
	}

	if len(competitorAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Competitor records in the query.
func (q competitorQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count competitors rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q competitorQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if competitors exists")
	}

	return count > 0, nil
}

// CompetitorNameSellersJSONHistories retrieves all the sellers_json_history's SellersJSONHistories with an executor via competitor_name column.
func (o *Competitor) CompetitorNameSellersJSONHistories(mods ...qm.QueryMod) sellersJSONHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"sellers_json_history\".\"competitor_name\"=?", o.CompetitorName),
	)

	return SellersJSONHistories(queryMods...)
}

// URLSellersJSONHistories retrieves all the sellers_json_history's SellersJSONHistories with an executor via url column.
func (o *Competitor) URLSellersJSONHistories(mods ...qm.QueryMod) sellersJSONHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"sellers_json_history\".\"url\"=?", o.URL),
	)

	return SellersJSONHistories(queryMods...)
}

// LoadCompetitorNameSellersJSONHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (competitorL) LoadCompetitorNameSellersJSONHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCompetitor interface{}, mods queries.Applicator) error {
	var slice []*Competitor
	var object *Competitor

	if singular {
		var ok bool
		object, ok = maybeCompetitor.(*Competitor)
		if !ok {
			object = new(Competitor)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCompetitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCompetitor))
			}
		}
	} else {
		s, ok := maybeCompetitor.(*[]*Competitor)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCompetitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCompetitor))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &competitorR{}
		}
		args[object.CompetitorName] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &competitorR{}
			}
			args[obj.CompetitorName] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`sellers_json_history`),
		qm.WhereIn(`sellers_json_history.competitor_name in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sellers_json_history")
	}

	var resultSlice []*SellersJSONHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sellers_json_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sellers_json_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sellers_json_history")
	}

	if len(sellersJSONHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CompetitorNameSellersJSONHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sellersJSONHistoryR{}
			}
			foreign.R.CompetitorNameCompetitor = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.CompetitorName == foreign.CompetitorName {
				local.R.CompetitorNameSellersJSONHistories = append(local.R.CompetitorNameSellersJSONHistories, foreign)
				if foreign.R == nil {
					foreign.R = &sellersJSONHistoryR{}
				}
				foreign.R.CompetitorNameCompetitor = local
				break
			}
		}
	}

	return nil
}

// LoadURLSellersJSONHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (competitorL) LoadURLSellersJSONHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCompetitor interface{}, mods queries.Applicator) error {
	var slice []*Competitor
	var object *Competitor

	if singular {
		var ok bool
		object, ok = maybeCompetitor.(*Competitor)
		if !ok {
			object = new(Competitor)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCompetitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCompetitor))
			}
		}
	} else {
		s, ok := maybeCompetitor.(*[]*Competitor)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCompetitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCompetitor))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &competitorR{}
		}
		args[object.URL] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &competitorR{}
			}
			args[obj.URL] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`sellers_json_history`),
		qm.WhereIn(`sellers_json_history.url in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sellers_json_history")
	}

	var resultSlice []*SellersJSONHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sellers_json_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sellers_json_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sellers_json_history")
	}

	if len(sellersJSONHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.URLSellersJSONHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sellersJSONHistoryR{}
			}
			foreign.R.URLCompetitor = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.URL, foreign.URL) {
				local.R.URLSellersJSONHistories = append(local.R.URLSellersJSONHistories, foreign)
				if foreign.R == nil {
					foreign.R = &sellersJSONHistoryR{}
				}
				foreign.R.URLCompetitor = local
				break
			}
		}
	}

	return nil
}

// AddCompetitorNameSellersJSONHistories adds the given related objects to the existing relationships
// of the competitor, optionally inserting them as new records.
// Appends related to o.R.CompetitorNameSellersJSONHistories.
// Sets related.R.CompetitorNameCompetitor appropriately.
func (o *Competitor) AddCompetitorNameSellersJSONHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SellersJSONHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CompetitorName = o.CompetitorName
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"sellers_json_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"competitor_name"}),
				strmangle.WhereClause("\"", "\"", 2, sellersJSONHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.CompetitorName, rel.CompetitorName, rel.URL}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CompetitorName = o.CompetitorName
		}
	}

	if o.R == nil {
		o.R = &competitorR{
			CompetitorNameSellersJSONHistories: related,
		}
	} else {
		o.R.CompetitorNameSellersJSONHistories = append(o.R.CompetitorNameSellersJSONHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sellersJSONHistoryR{
				CompetitorNameCompetitor: o,
			}
		} else {
			rel.R.CompetitorNameCompetitor = o
		}
	}
	return nil
}

// AddURLSellersJSONHistories adds the given related objects to the existing relationships
// of the competitor, optionally inserting them as new records.
// Appends related to o.R.URLSellersJSONHistories.
// Sets related.R.URLCompetitor appropriately.
func (o *Competitor) AddURLSellersJSONHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SellersJSONHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.URL, o.URL)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"sellers_json_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"url"}),
				strmangle.WhereClause("\"", "\"", 2, sellersJSONHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.URL, rel.CompetitorName, rel.URL}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.URL, o.URL)
		}
	}

	if o.R == nil {
		o.R = &competitorR{
			URLSellersJSONHistories: related,
		}
	} else {
		o.R.URLSellersJSONHistories = append(o.R.URLSellersJSONHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sellersJSONHistoryR{
				URLCompetitor: o,
			}
		} else {
			rel.R.URLCompetitor = o
		}
	}
	return nil
}

// Competitors retrieves all the records using an executor.
func Competitors(mods ...qm.QueryMod) competitorQuery {
	mods = append(mods, qm.From("\"competitors\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"competitors\".*"})
	}

	return competitorQuery{q}
}

// FindCompetitor retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCompetitor(ctx context.Context, exec boil.ContextExecutor, competitorName string, selectCols ...string) (*Competitor, error) {
	competitorObj := &Competitor{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"competitors\" where \"competitor_name\"=$1", sel,
	)

	q := queries.Raw(query, competitorName)

	err := q.Bind(ctx, exec, competitorObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from competitors")
	}

	if err = competitorObj.doAfterSelectHooks(ctx, exec); err != nil {
		return competitorObj, err
	}

	return competitorObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Competitor) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no competitors provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(competitorColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	competitorInsertCacheMut.RLock()
	cache, cached := competitorInsertCache[key]
	competitorInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			competitorAllColumns,
			competitorColumnsWithDefault,
			competitorColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(competitorType, competitorMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(competitorType, competitorMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"competitors\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"competitors\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into competitors")
	}

	if !cached {
		competitorInsertCacheMut.Lock()
		competitorInsertCache[key] = cache
		competitorInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Competitor.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Competitor) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	competitorUpdateCacheMut.RLock()
	cache, cached := competitorUpdateCache[key]
	competitorUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			competitorAllColumns,
			competitorPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update competitors, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"competitors\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, competitorPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(competitorType, competitorMapping, append(wl, competitorPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update competitors row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for competitors")
	}

	if !cached {
		competitorUpdateCacheMut.Lock()
		competitorUpdateCache[key] = cache
		competitorUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q competitorQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for competitors")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for competitors")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CompetitorSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), competitorPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"competitors\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, competitorPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in competitor slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all competitor")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Competitor) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no competitors provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(competitorColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	competitorUpsertCacheMut.RLock()
	cache, cached := competitorUpsertCache[key]
	competitorUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			competitorAllColumns,
			competitorColumnsWithDefault,
			competitorColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			competitorAllColumns,
			competitorPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert competitors, could not build update column list")
		}

		ret := strmangle.SetComplement(competitorAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(competitorPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert competitors, could not build conflict column list")
			}

			conflict = make([]string, len(competitorPrimaryKeyColumns))
			copy(conflict, competitorPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"competitors\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(competitorType, competitorMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(competitorType, competitorMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert competitors")
	}

	if !cached {
		competitorUpsertCacheMut.Lock()
		competitorUpsertCache[key] = cache
		competitorUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Competitor record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Competitor) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Competitor provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), competitorPrimaryKeyMapping)
	sql := "DELETE FROM \"competitors\" WHERE \"competitor_name\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from competitors")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for competitors")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q competitorQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no competitorQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from competitors")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for competitors")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CompetitorSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(competitorBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), competitorPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"competitors\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, competitorPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from competitor slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for competitors")
	}

	if len(competitorAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Competitor) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCompetitor(ctx, exec, o.CompetitorName)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CompetitorSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CompetitorSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), competitorPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"competitors\".* FROM \"competitors\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, competitorPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CompetitorSlice")
	}

	*o = slice

	return nil
}

// CompetitorExists checks if the Competitor row exists.
func CompetitorExists(ctx context.Context, exec boil.ContextExecutor, competitorName string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"competitors\" where \"competitor_name\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, competitorName)
	}
	row := exec.QueryRowContext(ctx, sql, competitorName)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if competitors exists")
	}

	return exists, nil
}

// Exists checks if the Competitor row exists.
func (o *Competitor) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return CompetitorExists(ctx, exec, o.CompetitorName)
}
